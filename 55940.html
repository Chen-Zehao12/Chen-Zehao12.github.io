<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Pandas | 陈泽豪</title><meta name="author" content="陈泽豪"><meta name="copyright" content="陈泽豪"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="pandas 是强大的数据分析和处理工具 pandas 常用的数据结构  Series：带标签的一维数组 DatetimeIndex：时间序列 DataFrame：带标签且大小可变的二维表格结构 Panel：带标签且大小可变的三维数组    1. pandas 读写数据  pandas 内置了 10 余种数据源读取函数和对应的数据写入函数  csv 文件 Excel 文件    1.1 读取 c">
<meta property="og:type" content="article">
<meta property="og:title" content="Pandas">
<meta property="og:url" content="https://chenzehao.com/55940.html">
<meta property="og:site_name" content="陈泽豪">
<meta property="og:description" content="pandas 是强大的数据分析和处理工具 pandas 常用的数据结构  Series：带标签的一维数组 DatetimeIndex：时间序列 DataFrame：带标签且大小可变的二维表格结构 Panel：带标签且大小可变的三维数组    1. pandas 读写数据  pandas 内置了 10 余种数据源读取函数和对应的数据写入函数  csv 文件 Excel 文件    1.1 读取 c">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7">
<meta property="article:published_time" content="2020-07-01T16:00:00.000Z">
<meta property="article:modified_time" content="2022-01-21T05:53:28.900Z">
<meta property="article:author" content="陈泽豪">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"><link rel="shortcut icon" href="https://tva1.sinaimg.cn/large/008i3skNgy1gyk8f9yfnqj305k05kglg.jpg"><link rel="canonical" href="https://chenzehao.com/55940"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><meta name="baidu-site-verification" content="code-GhGfwpqKHn"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?9191e58322566f7fdcbb360b8eeb1686";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'mediumZoom',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Pandas',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-01-21 13:53:28'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.0.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gyk8f9yfnqj305k05kglg.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">93</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">29</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><span> 笔记</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">陈泽豪</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><span> 笔记</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Pandas</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-07-01T16:00:00.000Z" title="发表于 2020-07-02 00:00:00">2020-07-02</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-01-21T05:53:28.900Z" title="更新于 2022-01-21 13:53:28">2022-01-21</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/">数据分析</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">8.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>33分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><ul>
<li>pandas 是强大的数据分析和处理工具</li>
<li>pandas 常用的数据结构
<ul>
<li>Series：带标签的一维数组</li>
<li>DatetimeIndex：时间序列</li>
<li>DataFrame：带标签且大小可变的二维表格结构</li>
<li>Panel：带标签且大小可变的三维数组</li>
</ul>
</li>
</ul>
<h2 id="1-pandas 读写数据">1. pandas 读写数据</h2>
<ul>
<li>pandas 内置了 10 余种数据源读取函数和对应的数据写入函数
<ul>
<li>csv 文件</li>
<li>Excel 文件</li>
</ul>
</li>
</ul>
<h3 id="1-1- 读取 csv 文件">1.1 读取 csv 文件</h3>
<ul>
<li>
<p>使用 read_table 函数读取文本文件</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pandas.read_table(filepath_or_buffer, sep=<span class="string">&#x27;\t&#x27;</span>, header=<span class="string">&#x27;infer&#x27;</span>, names=<span class="literal">None</span>, index_col=<span class="literal">None</span>, dtype=<span class="literal">None</span>, engine=<span class="literal">None</span>, nrows=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>使用 read_csv 函数读取 csv 文件</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pandas.read_csv(filepath_or_buffer, sep=<span class="string">&#x27;,&#x27;</span>, header=<span class="string">&#x27;infer&#x27;</span>, names=<span class="literal">None</span>, index_col=<span class="literal">None</span>, dtype=<span class="literal">None</span>, engine=<span class="literal">None</span>, nrows=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/05/28/tZ4hE4.png" alt="tZ4hE4.png"></p>
<ul>
<li>sep
<ul>
<li>指定文本的分隔符。如果分隔符指定错误，在读取数据的时候，每一行数据将会连成一片</li>
</ul>
</li>
<li>header
<ul>
<li>指定列名。如果是 None，则会添加一个默认的列名</li>
</ul>
</li>
<li>encoding
<ul>
<li>文件的编码格式。常用的编码有 utf-8、utf-16、gbk、gb2312、gb18030 等。如果编码指定错误，数据将无法读取，Python 解释器会报解析错误</li>
</ul>
</li>
</ul>
<h3 id="1-2- 存储 csv 文件">1.2 存储 csv 文件</h3>
<ul>
<li>
<p>结构化数据可以通过 pandas 中的 to_csv 函数实现以 csv 文件格式存储文件</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DataFrame.to_csv(path_or_buf=<span class="literal">None</span>, sep=<span class="string">&#x27;,&#x27;</span>, na_rep=<span class="string">&#x27;&#x27;</span>, columns=<span class="literal">None</span>, header=<span class="literal">True</span>, index=<span class="literal">True</span>, index_label=<span class="literal">None</span>, mode=<span class="string">&#x27;w&#x27;</span>, encoding=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/05/28/tZ5Hij.png" alt="tZ5Hij.png"></p>
<h3 id="1-3- 读取 excel 文件">1.3 读取 excel 文件</h3>
<ul>
<li>
<p>pandas 提供了 read_excel 函数来读取 xls、xlsx 两种 excel 文件</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pandas.read_excel(io, sheetname=<span class="number">0</span>, header=<span class="number">0</span>, index_col=<span class="literal">None</span>, names=<span class="literal">None</span>, dtype=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/05/28/tZ5jyV.png" alt="tZ5jyV.png"></p>
<h3 id="1-4- 存储 excel 文件">1.4 存储 excel 文件</h3>
<ul>
<li>
<p>将文件存储为 excel 文件，可以使用 to_excel 方法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DataFrame.to_excel(excel_writer=<span class="literal">None</span>, sheetname=<span class="literal">None</span>, na_rep=<span class="string">&#x27;&#x27;</span>, header=<span class="literal">True</span>, index=<span class="literal">True</span>, index_label=<span class="literal">None</span>, mode=<span class="string">&#x27;w&#x27;</span>, encoding=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>与 to_csv 方法的常用参数基本一致。区别之处在于指定存储文件的文件路径参数名为 excel_writer，并且没有 sep 参数，增加了一个 sheetname 参数用来指定存储的 excel sheet 的名称，默认为 sheet1</p>
</li>
</ul>
<h2 id="2-Series">2. Series</h2>
<ul>
<li>pandas 提供的一维数组，由索引和值两部分组成，类似字典，支持字典的一些方法</li>
<li>值的类型可以不同</li>
<li>如果在创建时没有明确指定索引，则会自动使用从 0 开始的非负整数作为索引</li>
</ul>
<h3 id="2-1- 创建 Series">2.1 创建 Series</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pandas.Series(data=<span class="literal">None</span>, index=<span class="literal">None</span>, dtype=<span class="literal">None</span>, name=<span class="literal">None</span>, copy=<span class="literal">False</span>, fastpath=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自动创建从 0 开始的非负整数索引</span></span><br><span class="line">s1 = pd.Series(<span class="built_in">range</span>(<span class="number">1</span>, <span class="number">20</span>, <span class="number">5</span>))</span><br><span class="line"><span class="comment"># 使用字典创建 Series，使用字典的键作为索引</span></span><br><span class="line">s2 = pd.Series(&#123;<span class="string">&#x27; 语文 &#x27;</span>: <span class="number">90</span>, <span class="string">&#x27; 数学 &#x27;</span>: <span class="number">92</span>, <span class="string">&#x27;Python&#x27;</span>: <span class="number">98</span>, <span class="string">&#x27; 物理 &#x27;</span>: <span class="number">87</span>, <span class="string">&#x27; 化学 &#x27;</span>: <span class="number">92</span>&#125;)</span><br><span class="line"><span class="comment"># 使用 array 创建 Series</span></span><br><span class="line">s3 = pd.Series(np.arange(<span class="number">5</span>, <span class="number">10</span>), index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>])</span><br></pre></td></tr></table></figure>
<h3 id="2-2-Series 索引">2.2 Series 索引</h3>
<ul>
<li>通过索引的方式选取 Series 中的单个或一组值</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自动创建从 0 开始的非负整数索引</span></span><br><span class="line">s1 = pd.Series(<span class="built_in">range</span>(<span class="number">1</span>, <span class="number">20</span>, <span class="number">5</span>))</span><br><span class="line"><span class="comment"># 使用字典创建 Series，使用字典的键作为索引</span></span><br><span class="line">s2 = pd.Series(&#123;<span class="string">&#x27; 语文 &#x27;</span>: <span class="number">90</span>, <span class="string">&#x27; 数学 &#x27;</span>: <span class="number">92</span>, <span class="string">&#x27;Python&#x27;</span>: <span class="number">98</span>, <span class="string">&#x27; 物理 &#x27;</span>: <span class="number">87</span>, <span class="string">&#x27; 化学 &#x27;</span>: <span class="number">92</span>&#125;)</span><br><span class="line"><span class="comment"># 使用 array 创建 Series</span></span><br><span class="line">s3 = pd.Series(np.arange(<span class="number">5</span>, <span class="number">10</span>), index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(s1[<span class="number">3</span>])</span><br><span class="line">s1[<span class="number">3</span>] = -<span class="number">17</span></span><br><span class="line"><span class="built_in">print</span>(s1)</span><br><span class="line"><span class="built_in">print</span>(s2[<span class="string">&#x27; 语文 &#x27;</span>])</span><br><span class="line">s2[<span class="string">&#x27; 语文 &#x27;</span>] = <span class="number">94</span></span><br><span class="line"><span class="built_in">print</span>(s2[[<span class="string">&#x27; 语文 &#x27;</span>, <span class="string">&#x27;Python&#x27;</span>]])  <span class="comment"># 放进列表中传入</span></span><br><span class="line"><span class="built_in">print</span>(s2[s2.values &gt;= <span class="number">90</span>])	<span class="comment"># 值条件</span></span><br><span class="line"><span class="built_in">print</span>(s3[s3.index != <span class="string">&#x27;d&#x27;</span>])	<span class="comment"># 索引条件</span></span><br></pre></td></tr></table></figure>
<h3 id="2-3- 基本运算">2.3 基本运算</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">s2.mean()           <span class="comment"># 均值</span></span><br><span class="line">s2.median()         <span class="comment"># 中位数</span></span><br><span class="line">s2.<span class="built_in">sum</span>()            <span class="comment"># 求和</span></span><br><span class="line">s2.std()            <span class="comment"># 标准差</span></span><br><span class="line">s2.mode()           <span class="comment"># 众数</span></span><br><span class="line">s2.value_counts()   <span class="comment"># 每个值的数量</span></span><br><span class="line">s2 / <span class="number">2</span>              <span class="comment"># 对每个值除以 2</span></span><br><span class="line">s2 // <span class="number">2</span>             <span class="comment"># 对每个值除以 2 后取整</span></span><br><span class="line">s2 % <span class="number">2</span>              <span class="comment"># 取余</span></span><br><span class="line">s2 ** <span class="number">2</span>             <span class="comment"># 求平方</span></span><br><span class="line">np.sqrt(s2)         <span class="comment"># 求开方</span></span><br><span class="line">np.log(s2)          <span class="comment"># 求对数</span></span><br><span class="line">s3 = s3.drop(<span class="string">&#x27;b&#x27;</span>)   <span class="comment"># 删除数据</span></span><br></pre></td></tr></table></figure>
<h2 id="3-DataFrame">3. DataFrame</h2>
<h3 id="3-1- 创建 DataFrame">3.1 创建 DataFrame</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pandas.DataFrame(data=<span class="literal">None</span>, index=<span class="literal">None</span>, columns=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>data
<ul>
<li>ndarray、list 或 dict</li>
</ul>
</li>
<li>index
<ul>
<li>行索引</li>
</ul>
</li>
<li>columns
<ul>
<li>列名列表</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">d = [[<span class="number">1.3</span>, <span class="number">2.0</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">4</span>], [<span class="number">2</span>, <span class="number">5</span>, <span class="number">1.9</span>, <span class="number">7</span>], [<span class="number">3</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">11</span>]]</span><br><span class="line">df = pd.DataFrame(d, index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>], columns=<span class="built_in">list</span>(<span class="string">&#x27;ABCD&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成缺失值矩阵</span></span><br><span class="line">df1 = pd.DataFrame(index=[<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>], columns=[<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(df1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成全零矩阵</span></span><br><span class="line">df2 = pd.DataFrame(<span class="number">0</span>, index=[<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>], columns=[<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(df2)</span><br><span class="line"></span><br><span class="line">d = &#123;<span class="string">&#x27;color&#x27;</span>: [<span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;yellow&#x27;</span>, <span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;white&#x27;</span>],</span><br><span class="line">     <span class="string">&#x27;object&#x27;</span>: [<span class="string">&#x27;ball&#x27;</span>, <span class="string">&#x27;pen&#x27;</span>, <span class="string">&#x27;pencil&#x27;</span>, <span class="string">&#x27;paper&#x27;</span>, <span class="string">&#x27;mug&#x27;</span>],</span><br><span class="line">     <span class="string">&#x27;price&#x27;</span>: [<span class="number">1.2</span>, <span class="number">1.0</span>, <span class="number">0.6</span>, <span class="number">0.9</span>, <span class="number">1.7</span>]&#125;</span><br><span class="line">df3 = pd.DataFrame(d, index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(df3)</span><br></pre></td></tr></table></figure>
<ul>
<li>基本属性</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/05/28/tZqife.png" alt="tZqife.png"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 DataFrame 的常用属性</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">detail = pd.read_excel(<span class="string">&#x27;...&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27; 订单详情表的索引为：&#x27;</span>, detail.index)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27; 订单详情表的所有值为：\n&#x27;</span>, detail.values)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27; 订单详情表的列名为：\n&#x27;</span>, detail.columns)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27; 订单详情表的数据类型为：\n&#x27;</span>, detail.dtypes)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看元素个数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27; 订单详情表的元素个数为：&#x27;</span>, detail.size)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27; 订单详情表的维度数为：&#x27;</span>, detail.ndim)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27; 订单详情表的形状为：&#x27;</span>, detail.shape)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 T 属性进行转置</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27; 订单详情表转置前形状为：&#x27;</span>, detail.shape)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27; 订单详情表转置后形状为为：&#x27;</span>, detail.T.shape)</span><br></pre></td></tr></table></figure>
<h3 id="3-2-DataFrame 基本操作">3.2 DataFrame 基本操作</h3>
<ul>
<li>
<p><strong>查询</strong></p>
</li>
<li>
<p><strong>打印所有列名</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DataFrame.columns</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>下单最多的商品</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DataFrame.groupby(<span class="string">&#x27;item_name&#x27;</span>).agg(&#123;<span class="string">&#x27;quatity&#x27;</span>:np.<span class="built_in">sum</span>&#125;).idxmax()</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>对单列数据的访问</strong>：DataFrame 的单列数据为一个 Series。有以下两种方式</p>
<ul>
<li>
<p>以字典访问某一个 key 的值的方式，使用对应的列名</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">order_id = detail[<span class="string">&#x27;order_id&#x27;</span>]</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>以属性的方式访问（不建议使用，易引起混淆）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dishes_name = detail.dishes_name</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><strong>对某一列的某几行访问</strong></p>
<ul>
<li>单独一列的 DataFrame 可以视为一个 Series</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dishes_name = detail[<span class="string">&#x27;dishes_name&#x27;</span>][:<span class="number">5</span>]</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>对多列数据访问</strong></p>
<ul>
<li>可以将多个列索引名称视为一个列表。同时访问 DataFrame 多列数据中的多行数据和访问单列数据的多行数据方法基本相同</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">orderDish = detail[[<span class="string">&#x27;order_id&#x27;</span>, <span class="string">&#x27;dishes_name&#x27;</span>]][:<span class="number">5</span>]</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><strong>对某几行访问</strong></p>
<ul>
<li>
<p>如果只是需要访问某几行数据，实现方式和上述的访问多列多行相似，选择所有列，使用“:”代替即可</p>
</li>
<li>
<p>head 和 tail 可以得到多行数据，但是用这两种方法得到的数据都是从开始或末尾获取的连续数据。默认参数为访问 5 行</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27; 订单详情表中前十行数据为：\n&#x27;</span>, detail.head(<span class="number">10</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27; 订单详情表中后五行数据为：\n&#x27;</span>, detail.tail())</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>loc 和 iloc 方法</strong></p>
<ul>
<li>loc 方法
<ul>
<li>针对 DataFrame 索引名称的切片方法，如果传入的不是索引名称，那么切片操作将无法执行。利用 loc 方法，能够实现所有单层索引切片操作</li>
<li>DataFrame.loc[行索引名称或条件, 列索引名称]</li>
</ul>
</li>
<li>iloc 方法
<ul>
<li>iloc 和 loc 区别：iloc 接收的必须是行索引和列索引的位置</li>
</ul>
</li>
<li>DataFrame.iloc[行索引位置, 列索引位置]</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 loc 和 iloc 实现单列切片</span></span><br><span class="line">dishes_name1 = detail.loc[:, <span class="string">&#x27;dishes_name&#x27;</span>]</span><br><span class="line">dishes_name2 = detail.iloc[:, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>
<ul>
<li>使用 loc 方法和 iloc 方法实现 <strong> 多列切片</strong>，其原理的通俗解释就是将多列的列名或者位置作为一个列表或者数据传入</li>
</ul>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment"># 使用 loc、iloc 实现多列切片</span></span><br><span class="line">  orderDish1 = detail.loc[:, [<span class="string">&#x27;order_id&#x27;</span>, <span class="string">&#x27;dishes_name&#x27;</span>]]</span><br><span class="line">  orderDish2 = detail.iloc[:, [<span class="number">1</span>, <span class="number">3</span>]]</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 使用 loc、iloc 实现花式切片</span></span><br><span class="line">  <span class="built_in">print</span>(detail.loc[<span class="number">3</span>, [<span class="string">&#x27;order_id&#x27;</span>, <span class="string">&#x27;dishes_name&#x27;</span>]])</span><br><span class="line">  <span class="built_in">print</span>(detail.loc[<span class="number">2</span>:<span class="number">6</span>, [<span class="string">&#x27;order_id&#x27;</span>, <span class="string">&#x27;dishes_name&#x27;</span>]])</span><br><span class="line"><span class="built_in">print</span>(detail.iloc[<span class="number">3</span>, [<span class="number">1</span>, <span class="number">3</span>]])</span><br><span class="line">  <span class="built_in">print</span>(detail.iloc[<span class="number">2</span>:<span class="number">7</span>, [<span class="number">1</span>, <span class="number">3</span>]])</span><br></pre></td></tr></table></figure>
<ul>
<li>在 loc 使用的时候，内部传入的行索引名称如果为一个区间，则 <strong> 前后均为闭区间</strong></li>
<li>在 iloc 使用的时候，内部传入的行索引位置或列索引位置为区间时，则为 <strong> 前闭后开区间</strong></li>
<li>loc 内部还可以传入 <strong> 表达式</strong>，结果会返回满足表达式的所有值</li>
</ul>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 loc 实现条件切片</span></span><br><span class="line">  <span class="built_in">print</span>(detail.loc[detail[<span class="string">&#x27;order_id&#x27;</span>] == <span class="number">458</span>, [<span class="string">&#x27;order_id&#x27;</span>, <span class="string">&#x27;dishes_name&#x27;</span>]])</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 使用 iloc 实现条件切片</span></span><br><span class="line"><span class="built_in">print</span>(detail.iloc[detail[<span class="string">&#x27;order_id&#x27;</span>] == <span class="number">458</span>, [<span class="number">1</span>, <span class="number">5</span>]])   		<span class="comment"># 出错，iloc 不接受 Series</span></span><br><span class="line">  <span class="built_in">print</span>(detail.iloc[(detail[<span class="string">&#x27;order_id&#x27;</span>] == <span class="number">458</span>).values, [<span class="number">1</span>, <span class="number">5</span>]])  <span class="comment"># 正确</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment"># 多条件索引</span></span><br><span class="line">gmv2 = df.loc[(df[<span class="string">&#x27; 交易额 &#x27;</span>] &gt;= <span class="number">300</span>) &amp; (df[<span class="string">&#x27; 交易额 &#x27;</span>] &lt;= <span class="number">800</span>), :]</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>loc 更加灵活多变，代码的可读性更高，iloc 的代码简洁，但可读性不高。大多数时候 <strong> 建议使用 loc 方法</strong></p>
</li>
<li>
<p>ix 方法</p>
<ul>
<li>ix 方法像是 loc 和 iloc 的融合</li>
<li>ix 方法在使用时既可以接受索引名称，也可以接受索引位置。
<ul>
<li>DataFrame.ix[行索引名称或位置或条件, 列索引名称或位置]</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(detail.ix[<span class="number">2</span>:<span class="number">6</span>, <span class="number">5</span>])	<span class="comment"># 优先识别为名称</span></span><br></pre></td></tr></table></figure>
<ul>
<li>当索引名称和位置存在部分重叠时，ix 默认优先识别名称</li>
<li>使用 ix 参数时，尽量保持行索引名称和行索引位置重叠。一律为 <strong> 闭区间</strong></li>
<li>使用列索引名称，而非列索引位置，以提高代码可读性</li>
<li>使用列索引位置时，<strong>需要注解</strong>，以提高代码可读性</li>
<li>缺点：面对数据量巨大的任务时，效率低于 loc 和 iloc 方法。建议使用 loc 和 iloc 方法</li>
</ul>
</li>
<li>
<p>以某字开头的数据</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以字母 G 开头的球队数据</span></span><br><span class="line">Gteam = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(euro12[<span class="string">&#x27;Team&#x27;</span>].size):</span><br><span class="line">    <span class="keyword">if</span> euro12[<span class="string">&#x27;Team&#x27;</span>][i][<span class="number">0</span>] == <span class="string">&#x27;G&#x27;</span>:</span><br><span class="line">        Gteam.append(i)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><strong>修改</strong></p>
<ul>
<li>更改 DataFrame 中的数据，原理是将这部分数据提取出来，重新赋值为新的数据</li>
<li>注意：数据更改直接针对 DataFrame 原数据更改，操作无法撤销。如果做出更改，需要对更改条件做确认或对数据进行备份</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 更改指定数据</span></span><br><span class="line">detail.loc[detail[<span class="string">&#x27;order_id&#x27;</span>] == <span class="number">458</span>, <span class="string">&#x27;order_id&#x27;</span>] = <span class="number">45800</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>将 str 类型（货币类型）转换为浮点数类型</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chipo[<span class="string">&#x27;item_price&#x27;</span>] = chipo[<span class="string">&#x27;item_price&#x27;</span>].<span class="built_in">str</span>[<span class="number">1</span>:].astype(<span class="string">&quot;float64&quot;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>排序</p>
<ul>
<li>先按 Red Cards 排序，再按 Yellow Cards 排序</li>
<li>ascending = True：升序</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">discipline = discipline.sort_values(ascending=<span class="literal">True</span>, by=[<span class="string">&#x27;Red Cards&#x27;</span>, <span class="string">&#x27;Yellow Cards&#x27;</span>])</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><strong>增添</strong></p>
</li>
<li>
<p>添加一列的方法非常简单，只需要新建一个列索引，并对该索引下的数据进行赋值即可</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建新列</span></span><br><span class="line">detail[<span class="string">&#x27;payment&#x27;</span>] = detail[<span class="string">&#x27;counts&#x27;</span>] * detail[<span class="string">&#x27;amounts&#x27;</span>]</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>若新增的一列值相同，则直接赋值一个常量即可</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建新列，并全部赋值为 cash</span></span><br><span class="line">detail[<span class="string">&#x27;pay_way&#x27;</span>] = <span class="string">&#x27;cash&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>删除</strong></p>
<ul>
<li>
<p>删除某列或某行数据时需要用到 pandas 提供的 drop 方法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DataFrame.drop(labels, axis=<span class="number">0</span>, level=<span class="literal">None</span>, inplace=<span class="literal">False</span>, errors=<span class="string">&#x27;raise&#x27;</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>axis=0：删除行</li>
<li>axis=1：删除列</li>
</ul>
</li>
<li>
<p>常用参数</p>
</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/05/28/teV58J.png" alt="teV58J.png"></p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">detail.drop(labels=<span class="string">&#x27;pay_way&#x27;</span>, axis=<span class="number">1</span>, inplace=<span class="literal">True</span>)		<span class="comment"># 删除一列</span></span><br><span class="line">detail.drop(labels=<span class="built_in">range</span>(<span class="number">1</span>, <span class="number">11</span>), axis=<span class="number">0</span>, inplace=<span class="literal">True</span>)	<span class="comment"># 删除一行，行索引</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="3-3- 分析 DataFrame 数据">3.3 分析 DataFrame 数据</h3>
<ul>
<li>数值型特征的描述性统计：计算数值型数据的完整情况、最小值、均值、中位数、最大值、四分位数、极差、标准差、方差、协方差和变异系数等</li>
<li>pandas 库基于 numpy，自然也可以用这些函数对数据框进行描述性统计</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/05/28/teZdqx.png" alt="teZdqx.png"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(np.mean(detail[<span class="string">&quot;amounts&quot;</span>]))</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>pandas 还提供了更加便利的方法来计算均值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(detail[<span class="string">&quot;amounts&quot;</span>].mean())</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>还提供了一个方法叫做 describe，能够一次性得出数据框所有数值型特征的非空值数目、均值、四分位数、标准差</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(detail[[<span class="string">&quot;amounts&quot;</span>, <span class="string">&#x27;counts&#x27;</span>]].describe())</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>获取 describe()中的单个内容</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(detail[[<span class="string">&quot;amounts&quot;</span>, <span class="string">&#x27;counts&#x27;</span>]].describe()[<span class="string">&#x27;top&#x27;</span>])</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/05/28/teZWLt.png" alt="image"></p>
<ul>
<li>
<p><strong>类别型特征的描述性统计</strong></p>
<ul>
<li>
<p>描述类别型特征的分布状况，可以使用频数统计表</p>
<ul>
<li>
<p>实现频数统计的方法：value_counts</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(detail[<span class="string">&#x27;dishes_name&#x27;</span>].value_count()[<span class="number">0</span>:<span class="number">10</span>])    <span class="comment"># 出现次数最多的前十名</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>pandas 提供了 categories 类，可以使用 astype 方法将目标特征的数据类型转换为 category 类别</p>
</li>
<li>
<p>describe 方法除了支持传统数值型以外，还能够支持对 category 类型的数据进行描述性统计</p>
<ul>
<li>四个统计量为：列非空元素的数目、类别的数目、数目最多的类别、数目最多的类别的数目</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">detail[<span class="string">&#x27;dishes_name&#x27;</span>] = detail[<span class="string">&quot;dishes_name&quot;</span>].astype(<span class="string">&#x27;category&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(detail[<span class="string">&#x27;dishes_name&#x27;</span>].describe())</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="4- 分析 datetime 数据">4. 分析 datetime 数据</h2>
<p><img src="https://s1.ax1x.com/2020/06/04/tBdDUA.png" alt="tBdDUA.png"></p>
<h3 id="4-1-Timestamp">4.1 Timestamp</h3>
<ul>
<li>
<p>时间类中最基础的一种，也是最常用的。多数情况下，时间相关的字符串都会转换成 Timestamp</p>
</li>
<li>
<p>to_datetime()，能够实现这一目标</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">order[<span class="string">&#x27;lock_time&#x27;</span>] = pd.to_datetime(order[<span class="string">&#x27;lock_time&#x27;</span>])</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Timestamp 类型时间是有限制的</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;min:&quot;</span>, pd.Timestamp.<span class="built_in">min</span>)  <span class="comment"># min: 1677-09-21 00:12:43.145225</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;max:&quot;</span>, pd.Timestamp.<span class="built_in">max</span>)  <span class="comment"># max: 2262-04-11 23:47:16.854775807</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Timestamp 类常用属性</p>
<ul>
<li>在多数涉及时间相关的数据处理、统计分析的过程中，需要提取时间中的年份、月份等数据，使用对应的 Timestamp 类属性可以实现这一目的</li>
<li>结合 Python 列表推导式，可以实现对 DataFrame 某一列时间信息数据的提取</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/06/04/tB08l6.png" alt="image"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 转换为 datetime</span></span><br><span class="line">order[<span class="string">&#x27;lock_time&#x27;</span>] = pd.to_datetime(order[<span class="string">&#x27;lock_time&#x27;</span>])</span><br><span class="line"></span><br><span class="line">year1 = [i.year <span class="keyword">for</span> i <span class="keyword">in</span> order[<span class="string">&#x27;lock_time&#x27;</span>]]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;lock_time 中的年份数据前 5 个为：&#x27;</span>, year1[:<span class="number">5</span>])</span><br><span class="line"></span><br><span class="line">month1 = [i.month <span class="keyword">for</span> i <span class="keyword">in</span> order[<span class="string">&#x27;lock_time&#x27;</span>]]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;lock_time 中的月份数据前 5 个为：&#x27;</span>, month1[:<span class="number">5</span>])</span><br><span class="line"></span><br><span class="line">day1 = [i.day <span class="keyword">for</span> i <span class="keyword">in</span> order[<span class="string">&#x27;lock_time&#x27;</span>]]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;lock_time 中的日期数据前 5 个为：&#x27;</span>, day1[:<span class="number">5</span>])</span><br><span class="line"></span><br><span class="line">weekday1 = [i.weekday_name <span class="keyword">for</span> i <span class="keyword">in</span> order[<span class="string">&#x27;lock_time&#x27;</span>]]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;lock_time 中的星期名称数据前 5 个为：&#x27;</span>, weekday1[:<span class="number">5</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 DatetimeIndex</span></span><br><span class="line">dateIndex = pd.DatetimeIndex(order[<span class="string">&quot;lock_time&quot;</span>])</span><br><span class="line"><span class="built_in">print</span>(dateIndex.weekday_name[:<span class="number">5</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 PeriodIndex</span></span><br><span class="line">periodIndex = pd.PeriodIndex(order[<span class="string">&quot;lock_time&quot;</span>], freq=<span class="string">&#x27;S&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(periodIndex.weekday[:<span class="number">5</span>])	<span class="comment"># 没有 weekday_name 属性，0 表示 Monday</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="4-2-DatetimeIndex 与 PeriodIndex">4.2 DatetimeIndex 与 PeriodIndex</h3>
<ul>
<li>
<p>除了将数据原始 DataFrame 中直接转换为 Timestamp 以外，还可以将数据单独提取出来转换为 DatetimeIndex 或 PeriodIndex</p>
</li>
<li>
<p>DatetimeIndex：用来指代一系列 <strong> 时间点 </strong> 的数据结构</p>
</li>
<li>
<p>PeriodIndex：用来指代一系列 <strong> 时间段 </strong> 的数据结构</p>
</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/06/04/tB08l6.png" alt="image"></p>
<ul>
<li>
<p>DatetimeIndex 与 PeriodIndex 函数</p>
<ul>
<li>
<p>除了将数据原始 DataFrame 中直接转换为 Timestamp 以外，还可以将数据单独提取出来转换为 DatetimeIndex 或 Periodndex</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 转换为 DatetimeIndex</span></span><br><span class="line">dateIndex = pd.DatetimeIndex(order[<span class="string">&quot;lock_time&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 转换为 PeriodIndex</span></span><br><span class="line">periodIndex = pd.PeriodIndex(order[<span class="string">&quot;lock_time&quot;</span>], freq=<span class="string">&#x27;S&#x27;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>转换为 PeriodIndex 时，需要通过 freq 参数指定时间间隔</p>
<ul>
<li>Y：年</li>
<li>M：月</li>
<li>D：日</li>
<li>H：小时</li>
<li>T：分钟</li>
<li>S：秒</li>
</ul>
</li>
<li>
<p>两个函数可以用来转换数据，还可以用来创建时间序列数据，参数非常相似</p>
</li>
</ul>
</li>
</ul>
<h3 id="4-3- 加减时间数据">4.3 加减时间数据</h3>
<ul>
<li>
<p>Timedelta 类</p>
<ul>
<li>Timedelta 是时间相关的类中的一个异类，不仅能够使用正数，还能够使用负数表示单位时间，例如 1 秒，2 分钟，3 小时等</li>
<li>使用 Timedelta 类，配合常规的时间相关类能够轻松实现时间的算术运算</li>
<li>目前 Timedelta 函数中时间周期 <strong> 没有 </strong> 年和月</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/06/04/tBBRKK.png" alt="image"></p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">order[<span class="string">&#x27;lock_time&#x27;</span>] = pd.to_datetime(order[<span class="string">&#x27;lock_time&#x27;</span>])         <span class="comment"># 转换为 datetime</span></span><br><span class="line"></span><br><span class="line">time1 = order[<span class="string">&#x27;lock_time&#x27;</span>] + pd.Timedelta(days=<span class="number">1</span>)</span><br><span class="line">timeDelta = order[<span class="string">&#x27;lock_time&#x27;</span>] - pd.to_datetime(<span class="string">&#x27;2017-1-1&#x27;</span>)     <span class="comment"># 字符串</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(timeDelta.dtypes) <span class="comment"># timedelta64[ns]</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">order = pd.read_table(<span class="string">&#x27;...&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 时间字符串转换为标准时间格式</span></span><br><span class="line">order[<span class="string">&#x27;use_start_time&#x27;</span>] = pd.to_datetime(order[<span class="string">&#x27;use_start_time&#x27;</span>])</span><br><span class="line">order[<span class="string">&#x27;lock_time&#x27;</span>] = pd.to_datetime(order[<span class="string">&#x27;lock_time&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 订单信息表时间信息提取</span></span><br><span class="line">year = [i.year <span class="keyword">for</span> i <span class="keyword">in</span> order[<span class="string">&#x27;lock_time&#x27;</span>]]             <span class="comment"># 提取年份信息</span></span><br><span class="line">month = [i.month <span class="keyword">for</span> i <span class="keyword">in</span> order[<span class="string">&#x27;lock_time&#x27;</span>]]           <span class="comment"># 提取月份信息</span></span><br><span class="line">day = [i.day <span class="keyword">for</span> i <span class="keyword">in</span> order[<span class="string">&#x27;lock_time&#x27;</span>]]               <span class="comment"># 提取日期信息</span></span><br><span class="line">week = [i.week <span class="keyword">for</span> i <span class="keyword">in</span> order[<span class="string">&#x27;lock_time&#x27;</span>]]             <span class="comment"># 提取周信息</span></span><br><span class="line">weekday = [i.weekday() <span class="keyword">for</span> i <span class="keyword">in</span> order[<span class="string">&#x27;lock_time&#x27;</span>]]     <span class="comment"># 提取星期信息</span></span><br><span class="line">weekname = [i.weekday_name <span class="keyword">for</span> i <span class="keyword">in</span> order[<span class="string">&#x27;lock_time&#x27;</span>]]	<span class="comment"># 提取星期名称信息，出错</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27; 订单详情表中的前 5 条数据的年份信息为：&#x27;</span>, year[:<span class="number">5</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27; 订单详情表中的前 5 条数据的月份信息为：&#x27;</span>, month[:<span class="number">5</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27; 订单详情表中的前 5 条数据的日期信息为：&#x27;</span>, day[:<span class="number">5</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27; 订单详情表中的前 5 条数据的周信息为：&#x27;</span>, week[:<span class="number">5</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27; 订单详情表中的前 5 条数据的星期信息为：&#x27;</span>, weekday[:<span class="number">5</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27; 订单详情表中的前 5 条数据的星期名称信息为：&#x27;</span>, weekname[:<span class="number">5</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看订单信息表时间统计信息</span></span><br><span class="line">timemin = order[<span class="string">&#x27;lock_time&#x27;</span>].<span class="built_in">min</span>()</span><br><span class="line">timemax = order[<span class="string">&#x27;lock_time&#x27;</span>].<span class="built_in">max</span>()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27; 订单最早的时间为：&#x27;</span>, timemin)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27; 订单最晚的时间为：&#x27;</span>, timemax)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27; 订单持续的时间为：&#x27;</span>, timemax - timemin)</span><br><span class="line"></span><br><span class="line">chekTime = order[<span class="string">&#x27;lock_time&#x27;</span>] - order[<span class="string">&#x27;use_start_time&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27; 平均点餐时间为：&#x27;</span>, chekTime.mean())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27; 最小点餐时间为：&#x27;</span>, chekTime.<span class="built_in">min</span>())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27; 最大点餐时间为：&#x27;</span>, chekTime.<span class="built_in">max</span>())</span><br></pre></td></tr></table></figure>
<h2 id="5- 分组聚合">5. 分组聚合</h2>
<p><img src="https://s1.ax1x.com/2020/05/28/tenSxJ.png" alt="tenSxJ.png"></p>
<h3 id="5-1-groupby 方法拆分数据">5.1 groupby 方法拆分数据</h3>
<ul>
<li>该方法提供的是分组聚合步骤中的拆分功能，能根据索引或字段对数据进行分组</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DataFrame.groupby(by=<span class="literal">None</span>, axis=<span class="number">0</span>, level=<span class="literal">None</span>, as_index=<span class="literal">True</span>, sort=<span class="literal">True</span>, group_keys=<span class="literal">True</span>, squeeze=<span class="literal">False</span>, **kwargs)</span><br></pre></td></tr></table></figure>
<p><img src="https://s1.ax1x.com/2020/05/28/tenKsA.png" alt="tenKsA.png"></p>
<ul>
<li>
<p>by 参数的特别说明</p>
<ul>
<li>如果传入的是一个函数，则对索引进行计算并分组</li>
<li>如果传入的是一个字典或者 Series，则字典或 Series 的值用来做分组依据</li>
<li>如果传入一个 Numpy 数组，则数据的元素作为分组依据</li>
<li>如果传入的是字符串或者字符串列表，则使用这些字符串所代表的字段作为分组依据</li>
</ul>
</li>
<li>
<p>groupby 对象常用的描述性统计方法</p>
<ul>
<li>
<p>用 groupby 方法分组后的结果并不能直接查看，而是被存在内存中，输出的是内存地址</p>
</li>
<li>
<p>groupby 对象常用的描述性统计方法</p>
<p><img src="https://s1.ax1x.com/2020/05/28/tenyJU.png" alt="tenyJU.png"></p>
</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">detail = pd.read_excel(<span class="string">&#x27;...&#x27;</span>)</span><br><span class="line"></span><br><span class="line">detailGroup = detail[[<span class="string">&#x27;order_id&#x27;</span>, <span class="string">&#x27;counts&#x27;</span>, <span class="string">&#x27;amounts&#x27;</span>]].groupby(by=<span class="string">&#x27;order_id&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27; 分组后的订单详情表为：&#x27;</span>, detailGroup)   <span class="comment"># 打印地址</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(detailGroup.mean().head())</span><br><span class="line"><span class="built_in">print</span>(detailGroup.std().head())</span><br><span class="line"><span class="built_in">print</span>(detailGroup.size().head())</span><br></pre></td></tr></table></figure>
<h3 id="5-2-agg 方法聚合数据">5.2 agg 方法聚合数据</h3>
<ul>
<li>
<p>agg 和 aggregate 函数参数及其说明</p>
<ul>
<li>
<p>agg、aggregate 方法都支持对每个分组应用其函数，包括 Python 内置函数或自定义函数。同时这两个方法也能够直接对 DataFrame 进行函数应用操作</p>
</li>
<li>
<p>在正常使用过程中，agg 函数和 aggregate 函数对 DataFrame 对象操作时功能几乎完全相同，因此只需要掌握其中一个函数即可</p>
<ul>
<li>
<pre><code class="language-python">DataFrame.agg(func, axis=0, *args, **kwargs)
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* ```python</span><br><span class="line">  DataFrame.aggregate(func, axis=0, *args, **kwargs)</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
</ul>
</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/05/28/teupY8.png" alt="teupY8.png"></p>
</li>
<li>
<p>agg 方法求统计量</p>
<ul>
<li>
<p>可以使用 agg 方法一次求出当前数据中所有菜品销量和售价的总和与均值</p>
<ul>
<li>
<pre><code class="language-python">detail[['counts', 'amounts']].agg([np.sum, np.mean])
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 对于某个字段希望只做求均值操作，而对另一个字段则希望只做求和操作，可以使用字典的方式，将两个字段名分别作为 key，然后将 numpy 库的求和与求均值的函数分别作为 value</span><br><span class="line"></span><br><span class="line">  * ```python</span><br><span class="line">    detail.agg(&#123;&#x27;counts&#x27;: np.sum, &#x27;amounts&#x27;: np.mean&#125;)</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
</ul>
</li>
<li>
<p>在某些时候还希望求出某个字段的多个统计量，某些字段则只需要求一个统计量，此时只需要将字典对应 key 的 value 变为列表，列表元素为多个目标的统计量即可</p>
<ul>
<li>
<pre><code class="language-python">detail.agg(&#123;'counts': np.sum, 'amounts': [np.mean, np.sum]&#125;)
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* agg 方法与自定义函数</span><br><span class="line"></span><br><span class="line">  * 在 agg 方法可传入自定义的函数</span><br><span class="line">  </span><br><span class="line">  ```python</span><br><span class="line">  # 自定义函数求两倍的和</span><br><span class="line">  def DoubleSum(data):</span><br><span class="line">      s = data.sum() * 2</span><br><span class="line">      return s</span><br><span class="line">  </span><br><span class="line">  print(&#x27; 菜品订单详情表的菜品销量两倍总和为：&#x27;, &#x27;\n&#x27;,</span><br><span class="line">        detail.agg(&#123;&#x27;counts&#x27;: DoubleSum&#125;, axis=0))</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
</ul>
</li>
<li>
<p>使用自定义函数需要注意的是 numpy 库中的函数 np.mean，np.median，np.prod，np.sum，np.std，np.var 能够在 agg 中直接使用，但是 <strong> 在自定义函数中 </strong> 使用 numpy 库中的这些函数，如果计算的时候是 <strong> 单个序列 </strong>，则会无法得出想要的结果，如果是<strong> 多列数据 </strong> 同时计算，则不会出现这种问题。因此尽量不要在自定义函数中使用 np 函数</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 自定义函数求两倍的和</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">DoubleSum1</span>(<span class="params">data</span>):</span></span><br><span class="line">    s = np.<span class="built_in">sum</span>(data) * <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27; 订单详情表的菜品销量两倍总和为：\n&#x27;</span>,</span><br><span class="line">      detail.agg(&#123;<span class="string">&#x27;counts&#x27;</span>: DoubleSum1&#125;, axis=<span class="number">0</span>).head())    <span class="comment"># 不正常结果</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27; 订单详情表的菜品销量与售价的和的两倍为：\n&#x27;</span>,</span><br><span class="line">      detail[[<span class="string">&#x27;counts&#x27;</span>, <span class="string">&#x27;amounts&#x27;</span>]].agg(DoubleSum1))        <span class="comment"># 正常结果</span></span><br></pre></td></tr></table></figure>
<ul>
<li>使用 agg 方法能够实现对每一个字段每一组使用相同的函数</li>
<li>agg 方法能够对 groupby 对象进行操作
<ul>
<li>如果需要对不同的字段应用不同的函数，则可以和 DataFrame 中使用 agg 方法相同</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(detailGroup.agg(np.mean).head(<span class="number">3</span>))</span><br><span class="line"><span class="built_in">print</span>(detailGroup.agg(np.std).head(<span class="number">3</span>))</span><br><span class="line"><span class="built_in">print</span>(detailGroup.agg(&#123;<span class="string">&#x27;counts&#x27;</span>: np.<span class="built_in">sum</span>, <span class="string">&#x27;amounts&#x27;</span>: np.mean&#125;).head(<span class="number">3</span>))</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="5-3-apply 方法聚合数据">5.3 apply 方法聚合数据</h3>
<ul>
<li>apply 方法类似 agg 方法能够将函数应用于每一列。不同之处在于，apply 方法传入的函数 <strong> 只能够作用于整个 DataFrame 或者 Series</strong>，而无法像 agg 一样能够对不同字段，应用不同函数，获取不同结果</li>
<li>使用 apply 方法对 groupby 对象进行聚合操作，其方法和 agg 方法相同，只是 agg 方法能够实现对不同字段进行应用不同的函数，而 apply 不能</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DataFrame.apply(func, axis=<span class="number">0</span>, broadcast=<span class="literal">False</span>, raw=<span class="literal">False</span>, reduce=<span class="literal">None</span>, args=(), **kwds)</span><br></pre></td></tr></table></figure>
<p><img src="https://s1.ax1x.com/2020/05/28/teKnHI.png" alt="teKnHI.png"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(detail[[<span class="string">&#x27;counts&#x27;</span>, <span class="string">&#x27;amounts&#x27;</span>]].apply(np.mean))</span><br><span class="line"><span class="built_in">print</span>(detailGroup.apply(np.mean).head(<span class="number">3</span>))</span><br><span class="line"><span class="built_in">print</span>(detailGroup.apply(np.std).head(<span class="number">3</span>))</span><br></pre></td></tr></table></figure>
<h3 id="5-4-transform 方法聚合数据">5.4 transform 方法聚合数据</h3>
<ul>
<li>
<p>transform 方法能够对整个 DataFrame 的所有元素进行操作。且 transform 方法只有一个参数 func，表示对 DataFrame 操作的函数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(detail[[<span class="string">&#x27;counts&#x27;</span>, <span class="string">&quot;amounts&quot;</span>]].transform(<span class="keyword">lambda</span> x: x * <span class="number">2</span>).head(<span class="number">4</span>))</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>同时 transform 方法还能够对 DataFrame 分组后的对象 groupby 进行操作，可以实现组内离差标准化等操作</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(detailGroup.transform(<span class="keyword">lambda</span> x: (x.mean() - x.<span class="built_in">min</span>()) / (x.<span class="built_in">max</span>() - x.<span class="built_in">min</span>())).head())</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>若在计算离差标准化的时候结果中有 NaN，这是由于根据离差标准化公式，最大值和最小值相同的情况下分母是 0，而分母为 0 的数在 Python 中表示为 NaN</p>
</li>
</ul>
<h2 id="6- 透视表与交叉表">6. 透视表与交叉表</h2>
<h3 id="6-1-pivot-table 创建透视表">6.1 pivot_table 创建透视表</h3>
<ul>
<li>
<pre><code class="language-python">pandas.pivot_table(data, values=None, index=None, columns=None, aggfunc='mean', fill_value=None, margins=False, dropna=True, margins_name='All')
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">![teKf56.png](https://s1.ax1x.com/2020/05/28/teKf56.png)</span><br><span class="line"></span><br><span class="line">* pivot_table 函数主要的参数调节</span><br><span class="line">  * 在不特殊指定聚合函数 aggfunc 时，默认使用 np.mean 进行聚合运算，np.mean 会自动过滤掉非数值类型数据，可以通过 aggfunc 参数修改聚合函数</span><br><span class="line">  * 和 groupby 方法分组的时候相同，pivot_table 函数在创建透视表的时候分组键 index 可以有多个</span><br><span class="line">  * 通过设置 columns 参数可以指定列分组</span><br><span class="line">  * 当全部数据列数很多时，若只想要显示某列，可以通过指定 values 参数实现</span><br><span class="line">  * 当某些数据不存在时，会自动填充 NaN，因此可以指定 fill_value 参数，表示当存在缺失值时，以指定数值进行填充</span><br><span class="line">  * 可以更改 margins 参数，查看汇总数据</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line"># 创建透视表</span><br><span class="line">detailPivot = pd.pivot_table(detail[[&#x27;order_id&#x27;, &#x27;counts&#x27;, &#x27;amounts&#x27;]],</span><br><span class="line">                             index=&#x27;order_id&#x27;)</span><br><span class="line"></span><br><span class="line"># 修改聚合函数后的透视表</span><br><span class="line">detailPivot1 = pd.pivot_table(detail[[&#x27;order_id&#x27;, &#x27;counts&#x27;, &#x27;amounts&#x27;]],</span><br><span class="line">                              index=&#x27;order_id&#x27;,</span><br><span class="line">                              aggfunc=np.sum)</span><br><span class="line"></span><br><span class="line"># 使用订单号和菜品名称作为索引的透视表</span><br><span class="line">detailPivot2 = pd.pivot_table(detail[[&#x27;order_id&#x27;, &#x27;dishes_name&#x27;,</span><br><span class="line">                                      &#x27;counts&#x27;, &#x27;amounts&#x27;]],</span><br><span class="line">                              index=[&#x27;order_id&#x27;, &#x27;dishes_name&#x27;],</span><br><span class="line">                              aggfunc=np.sum)</span><br><span class="line"></span><br><span class="line"># 指定菜品名称为列分组键的透视表</span><br><span class="line">detailPivot3 = pd.pivot_table(detail[[&#x27;order_id&#x27;, &#x27;dishes_name&#x27;,</span><br><span class="line">                                      &#x27;counts&#x27;, &#x27;amounts&#x27;]],</span><br><span class="line">                              index=&#x27;order_id&#x27;,</span><br><span class="line">                              columns=&#x27;dishes_name&#x27;,</span><br><span class="line">                              aggfunc=np.sum)</span><br><span class="line"></span><br><span class="line"># 指定某些列制作透视表</span><br><span class="line">detailPivot4 = pd.pivot_table(detail[[&#x27;order_id&#x27;, &#x27;dishes_name&#x27;,</span><br><span class="line">                                      &#x27;counts&#x27;, &#x27;amounts&#x27;]],</span><br><span class="line">                              index=&#x27;order_id&#x27;,</span><br><span class="line">                              columns=&quot;dishes_name&quot;,</span><br><span class="line">                              values=&#x27;counts&#x27;,</span><br><span class="line">                              aggfunc=np.sum)</span><br><span class="line"></span><br><span class="line"># 对透视表的缺失值进行填充</span><br><span class="line">detailPivot5 = pd.pivot_table(detail[[&#x27;order_id&#x27;, &#x27;dishes_name&#x27;,</span><br><span class="line">                                      &#x27;counts&#x27;, &#x27;amounts&#x27;]],</span><br><span class="line">                              index=&#x27;order_id&#x27;,</span><br><span class="line">                              columns=&#x27;dishes_name&#x27;,</span><br><span class="line">                              aggfunc=np.sum,</span><br><span class="line">                              fill_value=0)</span><br><span class="line"></span><br><span class="line"># 在透视表中添加汇总数据</span><br><span class="line">detailPivot6 = pd.pivot_table(detail[[&#x27;order_id&#x27;, &#x27;dishes_name&#x27;,</span><br><span class="line">                                      &#x27;counts&#x27;, &#x27;amounts&#x27;]],</span><br><span class="line">                              index=&#x27;order_id&#x27;,</span><br><span class="line">                              columns=&#x27;dishes_name&#x27;,</span><br><span class="line">                              aggfunc=np.sum,</span><br><span class="line">                              fill_value=0,</span><br><span class="line">                              margins=True)</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
</ul>
<h3 id="6-2-crosstab 创建交叉表">6.2 crosstab 创建交叉表</h3>
<ul>
<li>
<p>交叉表是一种特殊的透视表，主要用于计算分组频率</p>
</li>
<li>
<p>由于交叉表是透视表的一种，其参数基本保持一致，不同之处在于 crosstab 函数中的 index、columns、values 填入的都是对应的从 DataFrame 中取出的某一列</p>
</li>
<li>
<pre><code class="language-python">pandas.crosstab(index, columns, values=None, rownames=None, colnames=None, aggfunc=None, margins=False, dropna=True, normalize=False)
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  ![teMBdI.png](https://s1.ax1x.com/2020/05/28/teMBdI.png)</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line"># 创建交叉表</span><br><span class="line">detailCross = pd.crosstab(index=detail[&quot;order_id&quot;],</span><br><span class="line">                          columns=detail[&quot;dishes_name&quot;],</span><br><span class="line">                          values=detail[&quot;counts&quot;],</span><br><span class="line">                          aggfunc=np.sum)</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
</ul>
<h2 id="7- 数据预处理">7. 数据预处理</h2>
<ul>
<li>
<p>数据预处理是指对数据进行</p>
<ul>
<li>数据合并</li>
<li>数据清洗</li>
<li>数据标准化</li>
<li>数据变换</li>
</ul>
<p>并直接用于分析建模的这一过程的总称</p>
</li>
</ul>
<h3 id="7-1- 堆叠合并数据">7.1 堆叠合并数据</h3>
<ul>
<li>
<p>堆叠，即将两个表在 x 轴或 y 轴方向拼接在一起，可以使用 concat 函数完成</p>
<ul>
<li>
<pre><code class="language-python">pandas.concat(objs, axis=0, join='outer', join_axes=None,
              ignore_index=False, keys=None, levels=None, names=None,
              verify_integrity=False, copy=True)
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  * 参数</span><br><span class="line"></span><br><span class="line">    ![ttt4HO.png](https://s1.ax1x.com/2020/06/02/ttt4HO.png)</span><br><span class="line"></span><br><span class="line">    ![tttb8A.png](https://s1.ax1x.com/2020/06/02/tttb8A.png)</span><br><span class="line"></span><br><span class="line">* 横向表堆叠</span><br><span class="line"></span><br><span class="line">  * 使用 concat 函数时，当 axis=1 时，concat 做行对齐，然后将不同列名称的两张或多张表合并。当两个表索引不完全一样时，可以使用 join 参数选择是内连接还是外连接。</span><br><span class="line">    * 内连接 inner：仅仅返回索引重叠部分</span><br><span class="line">    * 外连接 outer：显示索引的并集部分数据，不足的地方则使用空值填补</span><br><span class="line">  * 当两张表完全一样时，不论 join 参数取值是 inner 或 outer，结果都是将两个表完全按照 x 轴拼接起来</span><br><span class="line"></span><br><span class="line">  ![ttNzsx.png](https://s1.ax1x.com/2020/06/02/ttNzsx.png)</span><br><span class="line"></span><br><span class="line">  ```python</span><br><span class="line">  print(pd.concat([df1, df2], axis=1, join=&#x27;inner&#x27;))  # 内连接</span><br><span class="line">  print(pd.concat([df1, df2], axis=1, join=&#x27;outer&#x27;))  # 外连接</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
</ul>
</li>
<li>
<p>纵向表堆叠</p>
<ul>
<li>使用 concat 函数时，在默认情况下，axis=0，concat 做列对齐，将不同行索引的两张或多张表纵向合并。在两张表的列名并不完全相同的情况下
<ul>
<li>内连接 inner：返回的仅仅是列名交集所代表的的列</li>
<li>外连接 outer：返回的是两者列名的并集所代表的的列</li>
</ul>
</li>
</ul>
</li>
<li>
<p>不论 join 参数取值是 inner 或 outer，结果都是将两个表完全按照 y 轴拼接起来</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(pd.concat([df3, df4], axis=<span class="number">0</span>, join=<span class="string">&#x27;inner&#x27;</span>))  <span class="comment"># 内连接</span></span><br><span class="line"><span class="built_in">print</span>(pd.concat([df3, df4], axis=<span class="number">0</span>, join=<span class="string">&#x27;outer&#x27;</span>))  <span class="comment"># 外连接</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>纵向堆叠——append 方法</p>
<ul>
<li>
<p>append 方法可以用于纵向合并两张表，但是 append 方法实现纵向表堆叠有一个前提条件，就是两张表的列名需要完全一致</p>
</li>
<li>
<pre><code class="language-python">pandas.DataFrame.append(self, other, ignore_index=False,
                        verify_integrity=False)
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 参数</span><br><span class="line"></span><br><span class="line">  ![ttd3Mn.png](https://s1.ax1x.com/2020/06/02/ttd3Mn.png)</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">df5 = df3.append(df4)</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
</ul>
</li>
<li>
<p>主键合并</p>
<ul>
<li>
<p>即通过一个或多个键将两个数据集的行连接起来。针对同一个主键存在两张包含不同字段的表，将其根据某几个字段一一对应拼接起来，结果集列数为两个原数据的列数之和减去连接键的数量</p>
<p><img src="https://s1.ax1x.com/2020/06/02/ttdxQs.png" alt="ttdxQs.png"></p>
</li>
<li>
<p><strong>merge 方法</strong></p>
<ul>
<li>
<p>merge 函数有左连接（left）、右连接（right）、内连接（inner）和外连接（outer）</p>
</li>
<li>
<pre><code class="language-python">pandas.merge(left, right, how='inner', on=None,
             left_on=None, right_on=None, left_index=False,
             right_index=False, sort=False, suffixes=('_x', '_y'), copy=True,
             indicator=False)
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 参数</span><br><span class="line"></span><br><span class="line">  ![ttwMTK.png](https://s1.ax1x.com/2020/06/02/ttwMTK.png)</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line"># 在订单详情表中为 order_id，在订单信息表中为 info_id</span><br><span class="line">order_detail = pd.merge(detail1, order, left_on=&#x27;order_id&#x27;, right_on=&#x27;info_id&#x27;, suffixes=(&#x27;_l&#x27;, &#x27;_r&#x27;))</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>join 方法</strong></p>
<ul>
<li>
<p>join 方法使用时，两个主键的名字必须相同</p>
</li>
<li>
<pre><code class="language-python">DataFrame.join(self, other, on=None, how='left', lsuffix='', rsuffix='', sort=False)
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">* 参数</span><br><span class="line">  </span><br><span class="line">  ![ttw0k8.png](https://s1.ax1x.com/2020/06/02/ttw0k8.png)</span><br><span class="line">  </span><br><span class="line">    ```python</span><br><span class="line">    order.rename(&#123;&#x27;info_id&#x27;: &quot;order_id&quot;&#125;, inplace=True)</span><br><span class="line">    order_detail = detail1.join(order, on=&#x27;order_id&#x27;, rsuffix=&#x27;1&#x27;)</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>combine_first 方法</strong></p>
<ul>
<li>
<p>数据分析和处理过程中若出现两份数据的内容几乎一致的情况，但是某些特征在其中一张表上是完整的，而在另一张表上的数据则是缺失的时候，可以用此方法进行重叠数据合并</p>
<p><img src="https://s1.ax1x.com/2020/06/02/ttw7c9.png" alt="ttw7c9.png"></p>
</li>
<li>
<pre><code class="language-python">DataFrame.combine_first(other)
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 参数</span><br><span class="line"></span><br><span class="line">  ![ttwjAK.png](https://s1.ax1x.com/2020/06/02/ttwjAK.png)</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">print(df5.combine_first(df6))</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="7-2- 检测与处理重复值">7.2 检测与处理重复值</h3>
<ul>
<li>
<p><strong>记录重复</strong></p>
<ul>
<li>即一个或多个特征某几个记录的值完全相同</li>
<li>方法一：利用列表（list）去重，自定义去重函数</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 自定义去重函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delRep</span>(<span class="params">list1</span>):</span></span><br><span class="line">    list2 = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> list1:</span><br><span class="line">        <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> list2:</span><br><span class="line">            list2.append(i)</span><br><span class="line">    <span class="keyword">return</span> list2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 去重</span></span><br><span class="line">dishes = <span class="built_in">list</span>(detail[<span class="string">&#x27;dishes_name&#x27;</span>])  	<span class="comment"># 将 dishes_name 从数据框中提取出来</span></span><br><span class="line">dish = delRep(dishes)  					<span class="comment"># 使用自定义的去重函数去重</span></span><br></pre></td></tr></table></figure>
<ul>
<li>方法二：利用集合（set）的元素是唯一的特性去重，不推荐，会重新排序</li>
</ul>
</li>
<li>
<p>drop_duplicates()去重</p>
<ul>
<li>
<p>只对 DataFrame 或 Series 类型有效</p>
<ul>
<li>不会改变数据原始排列，并且兼具代码简洁和运行稳定的特点</li>
<li>不仅支持单一特征的数据去重，还能够依据 DataFrame 的其中一个或几个特征进行去重</li>
</ul>
</li>
<li>
<pre><code class="language-python">DataFrame(Series).drop_duplicates(self, subset=None, keep='first', inplace=False)
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">* 参数</span><br><span class="line">  </span><br><span class="line">  ![ttBErR.png](https://s1.ax1x.com/2020/06/02/ttBErR.png)</span><br><span class="line">  </span><br><span class="line">    ```python</span><br><span class="line">  dishes_name = detail[&#x27;dishes_name&#x27;].drop_duplicates()	# 单一特征去重</span><br><span class="line">  detail.drop_duplicates(subset=[&quot;order_id&quot;, &#x27;emp_id&#x27;])	# 多个特征去重</span><br><span class="line">  detail.drop_duplicates(inplace = True)					# 样本去重</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>特征重复</strong></p>
<ul>
<li>
<p>可以通过 DataFrame.equals 方法进行特征去重</p>
</li>
<li>
<pre><code class="language-python">DataFrame.equals(self, other)
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 参数</span><br><span class="line"></span><br><span class="line">  ![ttBnIK.png](https://s1.ax1x.com/2020/06/02/ttBnIK.png)</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line"># 自定义特征去重函数</span><br><span class="line">def FeatureEquals(df):</span><br><span class="line">    dfEquals = pd.DataFrame([], columns=df.columns, index=df.columns)</span><br><span class="line">    for i in df.columns:</span><br><span class="line">        for j in df.columns:</span><br><span class="line">            dfEquals.loc[i, j] = df.loc[:, i].equals(df.loc[:, j])  # 赋值</span><br><span class="line">    return dfEquals</span><br><span class="line"></span><br><span class="line">detEquals = FeatureEquals(detail)  # 应用上述函数</span><br><span class="line"></span><br><span class="line">lenDet = detEquals.shape[0]</span><br><span class="line">dupCol = []</span><br><span class="line">for k in range(lenDet):</span><br><span class="line">    for l in range(k + 1, lenDet):</span><br><span class="line">        if detEquals.iloc[k, l] &amp; (detEquals.columns[l] not in dupCol):</span><br><span class="line">            dupCol.append(detEquals.columns[l])</span><br><span class="line"></span><br><span class="line">detail.drop(dupCol, axis=1, inplace=True)  # 进行去重操作</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="7-3- 检测与处理缺失值">7.3 检测与处理缺失值</h3>
<ul>
<li>
<p>isnull 或 notnull 方法寻找缺失值</p>
<ul>
<li>数据中的某个或某些特征的值是不完整的，这些值称为缺失值</li>
<li>isnull 和 notnull 方法在使用时返回的都是布尔值 True 和 False</li>
<li>结合 sum 函数和 isnull、notnull 函数，可以检测数据中缺失值的分布，以及数据中一共含有多少缺失值</li>
<li>isnull 和 notnull 之间结果正好相反，因此使用其一即可</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;detail 每个特征缺失的数目为：\n&#x27;</span>, detail.isnull().<span class="built_in">sum</span>())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;detail 每个特征非缺失的数目为：\n&#x27;</span>, detail.notnull().<span class="built_in">sum</span>())</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>删除法</p>
<ul>
<li>
<p>删除法分为删除观测记录和删除特征两种，它属于利用减少样本量来换取信息完整度的一种方法，是一种最简单的缺失值处理方法</p>
</li>
<li>
<p>dropna()</p>
<ul>
<li>
<p>该方法既可以删除观测记录，也可以删除特征</p>
</li>
<li>
<pre><code class="language-python">DataFrame.dropna(self, axis=0, how='any', thresh=None, subset=None, inplace=False)
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">* 参数</span><br><span class="line">  </span><br><span class="line">  ![ttrb8O.png](https://s1.ax1x.com/2020/06/02/ttrb8O.png)</span><br><span class="line">  </span><br><span class="line">    ```python</span><br><span class="line">    print(detail.dropna(axis=1, how=&#x27;any&#x27;).shape)   # 删除缺失值</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>替换法</p>
<ul>
<li>
<p>替换法是指用一个特定的值替换缺失值</p>
</li>
<li>
<p>特征可分为数值型和类别型，两者出现缺失值时处理的方法也不同</p>
<ul>
<li>缺失值所在特征为数值型时，通常利用其均值、中位数和众数等描述其集中趋势的统计量来代替缺失值</li>
<li>缺失值所在特征为类别型时，则选择使用众数来替换缺失值</li>
</ul>
</li>
<li>
<p>fillna()</p>
<ul>
<li>
<pre><code class="language-python">pandas.DataFrame.fillna(value=None, method=None, axis=None,
                        inplace=False, limit=None)
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 参数</span><br><span class="line"></span><br><span class="line">  ![ttsMGT.png](https://s1.ax1x.com/2020/06/02/ttsMGT.png)</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">detail = detail.fillna(-99)  # 用 -99 替换缺失值</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="7-4- 检测与处理异常值">7.4 检测与处理异常值</h3>
<ul>
<li>异常值是指严重超出正常范围的数值，这样的数据一般是数据采集错误或类似原因引起</li>
<li>在数据分析时，需要把这些数据删除或替换为特定的值（例如人为设定的正常范围边界值），减少对最终数据分析结果的影响</li>
<li>异常值处理的关键是根据实际情况准确定义正常范围边界值，超出正常范围的数值认为是异常值</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 异常交易额上浮 50%</span></span><br><span class="line">df.loc[df. 交易额 &lt; <span class="number">200</span>, <span class="string">&#x27; 交易额 &#x27;</span>] = df[df. 交易额 &lt; <span class="number">200</span>][<span class="string">&#x27; 交易额 &#x27;</span>].<span class="built_in">map</span>(<span class="keyword">lambda</span> num: num * <span class="number">1.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把低于 200 的交易额都替换为固定的 200</span></span><br><span class="line">df.loc[df. 交易额 &lt; <span class="number">200</span>, <span class="string">&#x27; 交易额 &#x27;</span>] = <span class="number">200</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 把高于 3000 的交易额都替换为固定的 3000</span></span><br><span class="line">df.loc[df. 交易额 &gt; <span class="number">3000</span>, <span class="string">&#x27; 交易额 &#x27;</span>] = <span class="number">3000</span></span><br></pre></td></tr></table></figure>
<h3 id="7-5- 数据标准化">7.5 数据标准化</h3>
<ul>
<li>
<p>离差标准化</p>
<ul>
<li>
<p>对原始数据的一种线性变换，结果是将原始数据的数值映射到 [0, 1] 区间</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msup><mi>X</mi><mo>∗</mo></msup><mo>=</mo><mfrac><mrow><mi>X</mi><mo>−</mo><mi>m</mi><mi>i</mi><mi>n</mi></mrow><mrow><mi>m</mi><mi>a</mi><mi>x</mi><mo>−</mo><mi>m</mi><mi>i</mi><mi>n</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">X^* = \frac{X-min}{max-min}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7387em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7387em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.1297em;vertical-align:-0.7693em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3603em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">min</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">min</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7693em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
</li>
<li>
<p>其中，max 为样本数据的最大值，min 为样本数据的最小值，max-min 为极差</p>
</li>
<li>
<p>离差标准化保留了原始数据值之间的联系，是消除量纲和数据取值范围影响最简单的方法</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 自定义离差标准化函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">MinMaxScale</span>(<span class="params">data</span>):</span></span><br><span class="line">    data = (data - data.<span class="built_in">min</span>()) / (data.<span class="built_in">max</span>() - data.<span class="built_in">min</span>())</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对菜品订单表售价和销量做离差标准化</span></span><br><span class="line">data1 = MinMaxScale(detail[<span class="string">&#x27;counts&#x27;</span>])</span><br><span class="line">data2 = MinMaxScale(detail[<span class="string">&#x27;amounts&#x27;</span>])</span><br><span class="line">data3 = pd.concat([data1, data2], axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>标准差标准化</p>
<ul>
<li>
<p>经该方法处理的数据均值为 0，标准差为 1</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msup><mi>X</mi><mo>∗</mo></msup><mo>=</mo><mfrac><mrow><mi>X</mi><mo>−</mo><mover accent="true"><mi>X</mi><mo stretchy="true">‾</mo></mover></mrow><mi>δ</mi></mfrac></mrow><annotation encoding="application/x-tex">X^* = \frac{X-\overline{X}}{\delta}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7387em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7387em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.2463em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.5603em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03785em;">δ</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span><span style="top:-3.8033em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
</li>
<li>
<p>数据中会出现负数</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 自定义标准差标准化函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">StandardScaler</span>(<span class="params">data</span>):</span></span><br><span class="line">    data = (data - data.mean()) / data.std()</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对菜品订单表售价和销量做标准化</span></span><br><span class="line">data4 = StandardScaler(detail[<span class="string">&#x27;counts&#x27;</span>])</span><br><span class="line">data5 = StandardScaler(detail[<span class="string">&#x27;amounts&#x27;</span>])</span><br><span class="line">data6 = pd.concat([data4, data5], axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
</article><div class="tag_share"><div class="post_share"><div class="social-share" data-image="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-pandas%20%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE"><span class="toc-text">1. pandas 读写数据</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%20%E8%AF%BB%E5%8F%96%20csv%20%E6%96%87%E4%BB%B6"><span class="toc-text">1.1 读取 csv 文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%20%E5%AD%98%E5%82%A8%20csv%20%E6%96%87%E4%BB%B6"><span class="toc-text">1.2 存储 csv 文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%20%E8%AF%BB%E5%8F%96%20excel%20%E6%96%87%E4%BB%B6"><span class="toc-text">1.3 读取 excel 文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-%20%E5%AD%98%E5%82%A8%20excel%20%E6%96%87%E4%BB%B6"><span class="toc-text">1.4 存储 excel 文件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Series"><span class="toc-text">2. Series</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%20%E5%88%9B%E5%BB%BA%20Series"><span class="toc-text">2.1 创建 Series</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-Series%20%E7%B4%A2%E5%BC%95"><span class="toc-text">2.2 Series 索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%20%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97"><span class="toc-text">2.3 基本运算</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-DataFrame"><span class="toc-text">3. DataFrame</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%20%E5%88%9B%E5%BB%BA%20DataFrame"><span class="toc-text">3.1 创建 DataFrame</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-DataFrame%20%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-text">3.2 DataFrame 基本操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%20%E5%88%86%E6%9E%90%20DataFrame%20%E6%95%B0%E6%8D%AE"><span class="toc-text">3.3 分析 DataFrame 数据</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%20%E5%88%86%E6%9E%90%20datetime%20%E6%95%B0%E6%8D%AE"><span class="toc-text">4. 分析 datetime 数据</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-Timestamp"><span class="toc-text">4.1 Timestamp</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-DatetimeIndex%20%E4%B8%8E%20PeriodIndex"><span class="toc-text">4.2 DatetimeIndex 与 PeriodIndex</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%20%E5%8A%A0%E5%87%8F%E6%97%B6%E9%97%B4%E6%95%B0%E6%8D%AE"><span class="toc-text">4.3 加减时间数据</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%20%E5%88%86%E7%BB%84%E8%81%9A%E5%90%88"><span class="toc-text">5. 分组聚合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-groupby%20%E6%96%B9%E6%B3%95%E6%8B%86%E5%88%86%E6%95%B0%E6%8D%AE"><span class="toc-text">5.1 groupby 方法拆分数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-agg%20%E6%96%B9%E6%B3%95%E8%81%9A%E5%90%88%E6%95%B0%E6%8D%AE"><span class="toc-text">5.2 agg 方法聚合数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-apply%20%E6%96%B9%E6%B3%95%E8%81%9A%E5%90%88%E6%95%B0%E6%8D%AE"><span class="toc-text">5.3 apply 方法聚合数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-transform%20%E6%96%B9%E6%B3%95%E8%81%9A%E5%90%88%E6%95%B0%E6%8D%AE"><span class="toc-text">5.4 transform 方法聚合数据</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%20%E9%80%8F%E8%A7%86%E8%A1%A8%E4%B8%8E%E4%BA%A4%E5%8F%89%E8%A1%A8"><span class="toc-text">6. 透视表与交叉表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-pivot-table%20%E5%88%9B%E5%BB%BA%E9%80%8F%E8%A7%86%E8%A1%A8"><span class="toc-text">6.1 pivot_table 创建透视表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-crosstab%20%E5%88%9B%E5%BB%BA%E4%BA%A4%E5%8F%89%E8%A1%A8"><span class="toc-text">6.2 crosstab 创建交叉表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%20%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86"><span class="toc-text">7. 数据预处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-%20%E5%A0%86%E5%8F%A0%E5%90%88%E5%B9%B6%E6%95%B0%E6%8D%AE"><span class="toc-text">7.1 堆叠合并数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-%20%E6%A3%80%E6%B5%8B%E4%B8%8E%E5%A4%84%E7%90%86%E9%87%8D%E5%A4%8D%E5%80%BC"><span class="toc-text">7.2 检测与处理重复值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-%20%E6%A3%80%E6%B5%8B%E4%B8%8E%E5%A4%84%E7%90%86%E7%BC%BA%E5%A4%B1%E5%80%BC"><span class="toc-text">7.3 检测与处理缺失值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-%20%E6%A3%80%E6%B5%8B%E4%B8%8E%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8%E5%80%BC"><span class="toc-text">7.4 检测与处理异常值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-5-%20%E6%95%B0%E6%8D%AE%E6%A0%87%E5%87%86%E5%8C%96"><span class="toc-text">7.5 数据标准化</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2022 By 陈泽豪</div><div class="footer_custom_text">我是豪豪</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex@latest/dist/contrib/copy-tex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/contrib/copy-tex.css"><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script><script>(() => {
  const $mermaidWrap = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaidWrap.length) {
    window.runMermaid = () => {
      window.loadMermaid = true
      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

      Array.from($mermaidWrap).forEach((item, index) => {
        const mermaidSrc = item.firstElementChild
        const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
        const mermaidID = 'mermaid-' + index
        const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent
        mermaid.mermaidAPI.render(mermaidID, mermaidDefinition, (svgCode) => {
          mermaidSrc.insertAdjacentHTML('afterend', svgCode)
        })
      })
    }

    const loadMermaid = () => {
      window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
    }

    window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
  }
})()</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script></div></body></html>
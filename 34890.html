<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>1- 操作系统常见知识点 | 陈泽豪</title><meta name="author" content="陈泽豪"><meta name="copyright" content="陈泽豪"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="进程和线程的区别？  【基本单位】进程是资源分配的最小单位。 线程是 CPU 调度的基本单位。 【内存资源】进程拥有独立的内存单元。同一进程下的多个线程共享内存。线程只独享指令流执行的必要资源，如寄存器和栈。 【相互影响】进程间不会相互影响，多考虑通信 。线程间会相互影响， 多考虑同步，通信可以不通过内核直接通信。 【切换开销】进程编程调试简单可靠性高，但是创建销毁切换开销大。线程正相反，开销小，">
<meta property="og:type" content="article">
<meta property="og:title" content="1- 操作系统常见知识点">
<meta property="og:url" content="https://chenzehao.com/34890.html">
<meta property="og:site_name" content="陈泽豪">
<meta property="og:description" content="进程和线程的区别？  【基本单位】进程是资源分配的最小单位。 线程是 CPU 调度的基本单位。 【内存资源】进程拥有独立的内存单元。同一进程下的多个线程共享内存。线程只独享指令流执行的必要资源，如寄存器和栈。 【相互影响】进程间不会相互影响，多考虑通信 。线程间会相互影响， 多考虑同步，通信可以不通过内核直接通信。 【切换开销】进程编程调试简单可靠性高，但是创建销毁切换开销大。线程正相反，开销小，">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7">
<meta property="article:published_time" content="2021-06-07T16:00:00.000Z">
<meta property="article:modified_time" content="2022-03-24T05:59:12.855Z">
<meta property="article:author" content="陈泽豪">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"><link rel="shortcut icon" href="https://tva1.sinaimg.cn/large/008i3skNgy1gyk8f9yfnqj305k05kglg.jpg"><link rel="canonical" href="https://chenzehao.com/34890"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><meta name="baidu-site-verification" content="code-GhGfwpqKHn"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?9191e58322566f7fdcbb360b8eeb1686";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'mediumZoom',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '1- 操作系统常见知识点',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-03-24 13:59:12'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.0.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gyk8f9yfnqj305k05kglg.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">85</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">24</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><span> 笔记</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">陈泽豪</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><span> 笔记</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">1- 操作系统常见知识点</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-06-07T16:00:00.000Z" title="发表于 2021-06-08 00:00:00">2021-06-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-03-24T05:59:12.855Z" title="更新于 2022-03-24 13:59:12">2022-03-24</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">12.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>35分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h3 id="进程和线程的区别？">进程和线程的区别？</h3>
<ol>
<li>【基本单位】进程是资源分配的最小单位。 线程是 CPU 调度的基本单位。</li>
<li>【内存资源】进程拥有独立的内存单元。同一进程下的多个线程共享内存。线程只独享指令流执行的必要资源，如寄存器和栈。</li>
<li>【相互影响】进程间不会相互影响，<strong>多考虑通信 </strong>。线程间会相互影响，<strong> 多考虑同步</strong>，通信可以不通过内核直接通信。</li>
<li>【切换开销】<strong>进程编程调试简单可靠性高，但是创建销毁切换开销大</strong>。线程正相反，开销小，切换速度快，但是编程调试相对复杂。</li>
</ol>
<h3 id="进程间通信的方式">进程间通信的方式</h3>
<p>管道、消息队列、共享内存、信号量、信号、Socket</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/165224175">张三同学没答好「进程间通信」，被面试官挂了…</a></p>
<p>由于每个进程的用户空间都是独立的，不能相互访问，这时就需要借助内核空间来实现进程间通信，原因很简单，每个进程都是共享一个内核空间。</p>
<p>Linux 内核提供了不少进程间通信的方式，其中最简单的方式就是管道，管道分为「匿名管道」和「命名管道」。</p>
<p><strong>匿名管道 </strong> 顾名思义，它没有名字标识，匿名管道是特殊文件只存在于内存，没有存在于文件系统中，shell 命令中的「 <code>|</code> 」竖线就是匿名管道，通信的数据是<strong> 无格式的流并且大小受限 </strong>，通信的方式是 <strong> 单向 </strong> 的，数据只能在一个方向上流动，如果要双向通信，需要创建两个管道，再来<strong> 匿名管道是只能用于存在父子关系的进程间通信</strong>，匿名管道的生命周期随着进程创建而建立，随着进程终止而消失。</p>
<p><strong>命名管道 </strong> 突破了匿名管道只能在亲缘关系进程间的通信限制，因为使用命名管道的前提，需要在文件系统创建一个类型为 p 的设备文件，那么毫无关系的进程就可以通过这个设备文件进行通信。另外，不管是匿名管道还是命名管道，进程写入的数据都是 <strong> 缓存在内核 </strong> 中，另一个进程读取数据时候自然也是从内核中获取，同时通信数据都遵循 <strong> 先进先出</strong> 原则，不支持 lseek 之类的文件定位操作。</p>
<p><strong>消息队列 </strong> 克服了管道通信的数据是无格式的字节流的问题，消息队列实际上是保存在内核的「消息链表」，消息队列的消息体是可以用户自定义的数据类型，发送数据时，会被分成一个一个独立的消息体，当然接收数据时，也要与发送方发送的消息体的数据类型保持一致，这样才能保证读取的数据是正确的。消息队列通信的速度不是最及时的，毕竟<strong> 每次数据的写入和读取都需要经过用户态与内核态之间的拷贝过程。</strong></p>
<p><strong>共享内存 </strong> 可以解决消息队列通信中用户态与内核态之间数据拷贝过程带来的开销，<strong> 它直接分配一个共享空间，每个进程都可以直接访问 </strong>，就像访问进程自己的空间一样快捷方便，不需要陷入内核态或者系统调用，大大提高了通信的速度，享有 <strong> 最快 </strong> 的进程间通信方式之名。但是便捷高效的共享内存通信，<strong> 带来新的问题，多进程竞争同个共享资源会造成数据的错乱。</strong></p>
<p>那么，就需要 <strong>信号量 </strong> 来保护共享资源，以确保任何时刻只能有一个进程访问共享资源，这种方式就是互斥访问。<strong> 信号量不仅可以实现访问的互斥性，还可以实现进程间的同步 </strong>，信号量其实是一个计数器，表示的是资源个数，其值可以通过两个原子操作来控制，分别是 <strong>P 操作和 V 操作</strong>。信号初始化为 <code>1</code>，就代表着是<strong> 互斥信号量 </strong>，它可以保证共享内存在任何时刻只有一个进程在访问，这就很好的保护了共享内存。信号初始化为 <code>0</code>，就代表着是<strong> 同步信号量</strong>，它可以保证进程 A 应在进程 B 之前执行。</p>
<p>与信号量名字很相似的叫 <strong> 信号 </strong>，它俩名字虽然相似，但功能一点儿都不一样。信号是进程间通信机制中<strong> 唯一的异步通信机制 </strong>，信号可以在应用进程和内核之间直接交互，内核也可以利用信号来通知用户空间的进程发生了哪些系统事件，信号事件的来源主要有硬件来源（如键盘 Cltr+C ）和软件来源（如 kill 命令），一旦有信号发生，<strong> 进程有三种方式响应信号 1. 执行默认操作、2. 捕捉信号、3. 忽略信号</strong>。有两个信号是应用进程无法捕捉和忽略的，即 <code>SIGKILL</code> 和 <code>SEGSTOP</code>，这是为了方便我们能在任何时候结束或停止某个进程。</p>
<p>前面说到的通信机制，都是工作于同一台主机，如果 <strong> 要与不同主机的进程间通信，那么就需要 Socket 通信了</strong>。Socket 实际上不仅用于不同的主机进程间通信，还可以用于本地主机进程间通信，可根据创建 Socket 的类型不同，分为三种常见的通信方式，一个是基于 TCP 协议的通信方式，一个是基于 UDP 协议的通信方式，一个是本地进程间通信方式。</p>
<p>以上，就是进程间通信的主要机制了。你可能会问了，那线程通信间的方式呢？</p>
<p>同个进程下的线程之间都是共享进程的资源，只要是共享变量都可以做到线程间通信，比如全局变量，所以对于线程间关注的不是通信方式，而是关注多线程竞争共享资源的问题，信号量也同样可以在线程间实现互斥与同步：</p>
<ul>
<li>互斥的方式，可保证任意时刻只有一个线程访问共享资源；</li>
<li>同步的方式，可保证线程 A 应在线程 B 之前执行；</li>
</ul>
<h3 id="对于 socket 通信，网络套接字和 Unix 域套接字的区别是什么？">对于 socket 通信，网络套接字和 Unix 域套接字的区别是什么？</h3>
<p>网络套接字可以用于单机进程间通信或者多机进程间通信，Unix 域套接字只能用于单机进程间通信。对于单机通信，后者开销更小，效率更高。</p>
<h3 id="线程间同步的方式（4 种常用方式）">线程间同步的方式（4 种常用方式）</h3>
<ul>
<li><strong>临界区</strong><br>
通过对多线程的 <strong>串行化</strong> 来访问公共资源或一段代码，速度快，适合控制数据访问。在任意时刻只允许一个线程对共享资源进行访问，如果有多个线程试图访问公共资源，那么在有一个线程进入后，其他试图访问公共资源的线程将被挂起，并一直等到进入临界区的线程离开，临界区在被释放后，其他线程才可以抢占。</li>
<li><strong>互斥量</strong><br>
互斥量和临界区很像，采用互斥量机制，只有拥有互斥量的线程才有访问公共资源的权限。因为互斥量只有一个，所以能保证公共资源不会同时被多个线程同时访问。当前拥有互斥量的线程处理完任务后必须将线程交出，以便其他线程访问该资源。</li>
<li><strong>信号量</strong><br>
它允许多个线程在同一时刻访问同一资源，但是需要限制在同一时刻访问此资源的最大线程数目。</li>
<li><strong>事件</strong><br>
通过通知操作的方式来保持线程的同步，还可以方便实现对多个线程的优先级比较的操作。</li>
</ul>
<h3 id="临界区和互斥量区别是什么？">临界区和互斥量区别是什么？</h3>
<p>临界区主要针对线程。</p>
<p>互斥量比临界区复杂。因为使用互斥不仅仅能够在 <strong> 同一应用程序不同线程 </strong> 中实现资源的安全共享，而且可以在 <strong> 不同应用程序的线程之间 </strong> 实现对资源的安全共享（注意是线程）。</p>
<p>互斥量与临界区的作用非常相似，但 <strong> 互斥量是可以命名的，也就是说它可以跨越进程使用 </strong>。所以创建互斥量需要的资源更多，<strong> 所以如果只为了在进程内部使用的话，使用临界区会带来速度上的优势并能够减少资源占用量</strong>。因为互斥量是跨进程的，互斥量一旦被创建，就可以通过名字打开它。</p>
<h3 id="多进程和多线程各自的应用场景">多进程和多线程各自的应用场景</h3>
<ol>
<li>需要 <strong> 频繁创建销毁 </strong> 的，优先使用线程。例如：web 服务器，来一个建立一个线程，断了就销毁线程。要是用进程，创建和销毁的代价是很难承受的。</li>
<li>需要 <strong> 进行大量的计算</strong>，优先使用线程。所谓大计算量，就是消耗 CPU 很多，切换频繁，这种情况用线程最合适。例如：图像处理，算法处理。</li>
<li><strong>强相关处理 </strong> 用线程，<strong>弱相关处理 </strong> 用进程。一般的 server 需要完成的任务如下：消息接发和消息处理。接发消息和消息处理就是弱相关任务，而消息处理里面又能分为消息解码，业务处理，这两个任务相对来说相关性强很多，因此，消息接发和消息处理可以分进程设计，消息解码和业务处理可以分线程设计。</li>
<li>可能扩展到 <strong> 多机分布 </strong> 的用多进程，多核分布用多线程。</li>
</ol>
<h3 id="多线程一定比单线程好吗？">多线程一定比单线程好吗？</h3>
<p>不一定，因为多线程的上下文切换和线程创建所带来的开销会带来一定的消耗。</p>
<p>在单 CPU 的情况下，一个线程累加 count，一个线程累减 count；另一个在单线程中完成这两个。当 count 小于 10 万时，单线程更快，大于 10 万时多线程更快。</p>
<h3 id="调度算法">调度算法</h3>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/JWj6_BF9Xc84kQcyx6Nf_g">大厂面试爱问的「调度算法」，20 张图一举拿下</a></p>
<p><strong>进程调度算法</strong></p>
<ul>
<li>先来先服务调度算法</li>
<li>最短作业优先调度算法</li>
<li>高响应比优先调度算法</li>
<li>时间片轮转调度算法</li>
<li>最高优先级调度算法</li>
<li>多级反馈队列调度算法</li>
</ul>
<p><strong>页面置换算法</strong></p>
<ul>
<li>最佳页面置换算法</li>
<li>先进先出置换算法</li>
<li>最近最久未使用的置换算法</li>
<li>时钟页面置换算法</li>
<li>最不常用置换算法</li>
</ul>
<p><strong>磁盘调度算法</strong></p>
<ul>
<li>先来先服务算法</li>
<li>最短寻道时间优先算法</li>
<li>扫描算法(电梯算法)</li>
<li>循环扫描算法</li>
<li>LOOK 与 C-LOOK 算法</li>
</ul>
<h3 id="虚拟内存">虚拟内存</h3>
<p>最开始的时候，程序运行就是直接放进内存的，但是 <strong> 内存空间有限 </strong>，程序放的时候成块放，有时候会造成内存空间的浪费或者造成大量的<strong> 内存碎片</strong>，于是决定在磁盘上找一个空间，用来扩大内存，磁盘这段空间就成为虚拟内存。光扩大内存还不行，必须要减少内存碎片，所以，将物理内存进行了分页，每一页大小相等，同时将虚拟内存也进行了分页。平时不需要的就放在磁盘中，需要运行的磁盘通过虚拟内存放到实际的主存中，这样就不害怕主存太满放不下了。虚拟内存存放在磁盘里，它里面包括不存在的，未映射的和已经映射的内存地址。但是如果分页太多的话，每次调用进程就会特别占空间，所以又在内存中划分出一块空间，作为一级页表，后续需要哪一个页，再调用对应的页表进行查询转换。页表中存放的是虚拟地址和物理地址的映射关系。MMU 负责根据页表将虚拟地址转换为实际地址。TLB 里面是高速缓存，每次映射前可以先从 TLB 中查找是否有想用的缓存，可以大大提高转换效率。页表中的有效位会判断是否物理地址是否为空。缺页时会从主存里面选择一个牺牲页，并把该牺牲页的内容拷回到磁盘里，然后用需要的地址取代它。</p>
<h3 id="程序运行需要经过哪几个步骤">程序运行需要经过哪几个步骤</h3>
<p><strong>1）预编译</strong></p>
<p><strong>gcc -E hello.c -o hello.i</strong></p>
<p>主要处理源代码文件中的以“#”开头的预编译指令。处理规则见下</p>
<ol>
<li>删除所有的 #define，展开所有的宏定义。</li>
<li>处理所有的条件预编译指令，如“#if”、“#endif”、“#ifdef”、“#elif”和“#else”。</li>
<li>处理“#include”预编译指令，将文件内容替换到它的位置，这个过程是递归进行的，文件中包含其他文件。</li>
<li>删除所有的注释，“//”和“/**/”。</li>
<li>保留所有的 #pragma 编译器指令，编译器需要用到他们，如：#pragma once 是为了防止有文件被重复引用。</li>
<li>添加行号和文件标识，便于编译时编译器产生调试用的行号信息，和编译时产生编译错误或警告时能够显示行号。</li>
</ol>
<p><strong>2）编译</strong></p>
<p><strong>gcc -S hello.i -o hello.s</strong></p>
<p>把预编译之后生成的 xxx.i 或 xxx.ii 文件，进行一系列词法分析、语法分析、语义分析及优化后，生成相应的汇编代码文件。</p>
<ol>
<li><strong>词法分析</strong>：利用类似于“有限状态机”的算法，将源代码程序输入到扫描机中，将其中的字符序列分割成一系列的记号。</li>
<li><strong>语法分析</strong>：语法分析器对由扫描器产生的记号，进行语法分析，产生语法树。由语法分析器输出的语法树是一种以表达式为节点的树。</li>
<li><strong>语义分析</strong>：语法分析器只是完成了对表达式语法层面的分析，语义分析器则对表达式是否有意义进行判断，其分析的语义是静态语义——在编译期能分期的语义，相对应的动态语义是在运行期才能确定的语义。</li>
<li><strong>优化</strong>：源代码级别的一个优化过程。</li>
<li><strong>目标代码生成</strong>：由代码生成器将中间代码转换成目标机器代码，生成一系列的代码序列——汇编语言表示。</li>
<li><strong>目标代码优化</strong>：目标代码优化器对上述的目标机器代码进行优化：寻找合适的寻址方式、使用位移来替代乘法运算、删除多余的指令等。</li>
</ol>
<p><strong>3）汇编</strong></p>
<p><strong>gcc -c hello.s -o hello.o</strong></p>
<p>将汇编代码转变成机器可以执行的指令(机器码文件)。 汇编器的汇编过程相对于编译器来说更简单，没有复杂的语法，也没有语义，更不需要做指令优化，只是根据汇编指令和机器指令的对照表一一翻译过来，汇编过程有汇编器 as 完成。经汇编之后，产生目标文件(与可执行文件格式几乎一样)xxx.o(Windows 下)、xxx.obj(Linux 下)。</p>
<p><strong>4）链接</strong></p>
<p><strong>gcc -o hello.o -o hello</strong></p>
<p>将不同的源文件产生的目标文件进行链接，从而形成一个可以执行的程序。链接分为静态链接和动态链接：</p>
<p><strong>静态链接</strong>：</p>
<p>函数和数据被编译进一个二进制文件。在使用静态库的情况下，在编译链接可执行文件时，链接器从库中复制这些函数和数据并把它们和应用程序的其它模块组合起来创建最终的可执行文件。</p>
<ul>
<li>
<p><strong>空间浪费</strong>：因为每个可执行程序中对所有需要的目标文件都要有一份副本，所以如果多个程序对同一个目标文件都有依赖，会出现同一个目标文件都在内存存在多个副本；</p>
</li>
<li>
<p><strong>更新困难</strong>：每当库函数的代码修改了，这个时候就需要重新进行编译链接形成可执行程序。</p>
</li>
<li>
<p><strong>运行速度快</strong>：在可执行程序中已经具备了所有执行程序所需要的任何东西，在执行的时候运行速度快。</p>
</li>
</ul>
<p><strong>动态链接：</strong></p>
<p>动态链接的基本思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形成一个完整的程序，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件。</p>
<ul>
<li>
<p><strong>共享库</strong>：就是即使需要每个程序都依赖同一个库，但是该库不会像静态链接那样在内存中存在多份副本，而是这多个程序在执行时共享同一份副本；</p>
</li>
<li>
<p><strong>更新方便</strong>：更新时只需要替换原来的目标文件，而无需将所有的程序再重新链接一遍。当程序下一次运行时，新版本的目标文件会被自动加载到内存并且链接起来，程序就完成了升级的目标。</p>
</li>
<li>
<p><strong>性能损耗</strong>：因为把链接推迟到了程序运行时，所以每次执行程序都需要进行链接，所以性能会有一定损失。</p>
</li>
</ul>
<h3 id="互斥锁和读写锁的区别">互斥锁和读写锁的区别</h3>
<p>读写锁比互斥锁有更高的并行性。</p>
<p>一个线程被互斥锁加锁之后，其他的线程必须等该互斥锁解锁之后才能加锁，而读写锁的读模式可以允许多个线程同时进行读加锁。</p>
<ul>
<li>
<p><strong>互斥锁</strong>：抢锁失败主动放弃 CPU 进入睡眠，解锁的时候需要操作系统唤醒。</p>
</li>
<li>
<p><strong>自旋锁</strong>：抢锁失败不放弃 CPU，不断循环尝试获取锁。适用于加锁时间短的场景。</p>
</li>
</ul>
<h3 id="为什么会发生死锁">为什么会发生死锁</h3>
<p><strong>死锁的概念</strong></p>
<p>在两个或者多个并发进程中，每个进程持有某种资源而又等待其它进程释放它们现在保持着的资源，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁(deadlock)。</p>
<p><strong>死锁的必要条件</strong></p>
<img src="https://tva1.sinaimg.cn/large/008i3skNly1gz55qmh7spj30to0d0gmf.jpg" alt="image-20220207191038377" style="zoom:50%;" />
<ul>
<li><strong>互斥</strong>：每个资源要么已经分配给了一个进程，要么就是可用的。</li>
<li><strong>占有和等待</strong>：已经得到了某个资源的进程可以再请求新的资源。</li>
<li><strong>不可抢占</strong>：已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显式地释放。</li>
<li><strong>环路等待</strong>：有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源。</li>
</ul>
<p><strong>解决方法</strong>：</p>
<ul>
<li>
<p><strong>鸵鸟策略</strong></p>
<p>直接忽略死锁。因为解决死锁问题的代价很高，因此鸵鸟策略这种不采取任务措施的方案会获得更高的性能。当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略。</p>
</li>
<li>
<p><strong>死锁预防</strong></p>
<p>基本思想是破坏形成死锁的四个必要条件</p>
</li>
</ul>
<h3 id="死锁预防">死锁预防</h3>
<ul>
<li>
<p>第一个条件一般不好破坏</p>
</li>
<li>
<p><strong>破坏占有和等待</strong>：每个请求者一次性申请所有需要的资源，如果无法申请就等待。这样就不会占有资源再去申请其他资源。缺点就是编程复杂，资源利用效率低，有些资源申请之后可能长期不用。</p>
</li>
<li>
<p><strong>破坏不可抢占</strong>：当某个线程拿到一部分资源之后，又去申请其他的资源，如果申请不到，主动释放占有的所有资源。</p>
</li>
<li>
<p><strong>破环循环等待</strong>：给每个资源编号，先申请编号小的，再申请编号大的。缺点是仍然会造成资源浪费。</p>
</li>
</ul>
<p>现实情况下遇到死锁都 <strong> 是直接忽略死锁，或者重启解决</strong>，这样相比死锁预防和死锁避免和死锁检测加恢复代价都是最低的。</p>
<h3 id="怎么避免死锁">怎么避免死锁</h3>
<ul>
<li>
<p><strong>银行家算法</strong></p>
<p>当进程首次申请资源时，要测试该进程对资源的 <strong> 最大需求量</strong>，如果系统现存的资源可以满足它的最大需求量则按当前的申请量分配资源，否则就推迟分配。</p>
<p>当进程在执行中继续申请资源时，先测试该进程已占用的资源数与本次申请资源数之和是否超过了该进程对资源的最大需求量。若超过则拒绝分配资源。若没超过则再测试系统现存的资源能否满足该进程尚需的最大资源量，若满足则按当前的申请量分配资源，否则也要推迟分配。</p>
</li>
<li>
<p><strong>安全序列</strong></p>
<p>是指系统能按某种进程推进顺序（P1, P2, P3, …, Pn），为每个进程 Pi 分配其所需要的资源，直至满足每个进程对资源的最大需求，使每个进程都可以顺序地完成。这种推进顺序就叫安全序列【银行家算法的核心就是找到一个安全序列】。</p>
</li>
<li>
<p><strong>系统安全状态</strong></p>
<p>如果系统能找到一个安全序列，就称系统处于安全状态，否则，就称系统处于不安全状态。</p>
</li>
</ul>
<h3 id="操作系统放在内存的低地址还是高地址？">操作系统放在内存的低地址还是高地址？</h3>
<p>操作系统放在虚拟内存的高地址，物理内存的低地址。</p>
<h3 id="进程经常在内存和磁盘间换入换出，怎样保证每次换入换出后进程中的指令跳转的地址不会混乱？">进程经常在内存和磁盘间换入换出，怎样保证每次换入换出后进程中的指令跳转的地址不会混乱？</h3>
<p>程序运行时会 <strong> 重定位地址</strong>，每段进程换入内存运行时都会在 PCB 中保存该进程的基地址，跳转地址指令一般都是偏移地址，跳转的时候会取出 PCB 中的基地址加上偏移地址得到需要跳转的地址。PCB 中的 LDT 表保存着该进程各个段的基地址。</p>
<h3 id="为什么内存比磁盘快？">为什么内存比磁盘快？</h3>
<p>硬盘是 <strong> 有机械结构 </strong> 的，磁头要运动到相应的位置，转片还在转动，然后读取此信号。</p>
<p>内存是 <strong> 没有机械结构 </strong> 的，是电，瞬间到达。电的到达速度要比磁头的运动快很多，比盘算转动也快得多，所以，有机械结构的磁头读取速度是不能和无机械结构电的速度相比的。</p>
<h3 id="进程间的切换和线程间的切换">进程间的切换和线程间的切换</h3>
<p>一个进程存储在处理器各寄存器中的中间数据叫做进程的上下文，所以进程的切换实质上就是被中止运行进程与待运行进程上下文的切换。在进程未占用处理器时，进程 的上下文是存储在进程的私有堆栈中的。</p>
<p><strong>进程的组成</strong>：进程控制块 PCB（灵魂），还有程序（躯体）如代码、数据、堆栈等、还有页表。进程有 3G 的用户空间（用户栈）和 1G 的内核空间（内核栈）。</p>
<p>PCB 主要是 task_struct 结构体，里面有一个 void *stack 指针指向内核栈，还有一个 mm 指针指向用户栈地址。</p>
<p>进程陷入内核态后，先把用户态堆栈的地址保存在内核栈之中。</p>
<p><strong>进程的上下文</strong>：用户级上下文（地址空间中的程序块，数据块，堆栈等 ），系统级上下文（PCB、内核栈等），寄存器上下文（硬件上下文）。</p>
<p>上下文切换时，操作系统 <strong> 把进程的寄存器上下文保存到系统级上下文中</strong>。因为 PCB 比较小，不能容纳那么多信息，所以大多数信息保存在内核栈和另外一个地方(linux 中)，然后 PCB 中有一个指针指向内核栈等，内核栈中保存现场和断点。</p>
<p><strong>什么时候发生上下文切换？</strong></p>
<p>自身造成切换，运行态变为阻塞态（自身产生一个异常、等待资源，启动 IO），外界强制下切换，运行态变为就绪态（时间片、优先级等），上下文切换的频率 1s 中可以达到 100-1000 次左右。</p>
<p><strong>PCB 和内核栈有什么关系？</strong></p>
<p>进程中的 PCB 的指针指向内核栈。内核栈里保存有进程上下文切换的各个寄存器的信息。每次切换完进程之后，新的进程根据当前进程 PCB 中的指向内核栈的指针，拿到该进程运行所需要的寄存器的信息。</p>
<p>PCB 也在内核栈里面，一般切换时信息都是保存在 PCB 中，PCB 装不下就用个指针指向内核栈进行保存。</p>
<p><strong>进程间切换：</strong></p>
<ol>
<li>
<p>切换 <strong> 新的页表</strong>，然后使用新的虚拟地址空间</p>
</li>
<li>
<p>切换 <strong> 内核栈</strong>，加入新的内容(PCB 控制块，资源相关)，硬件上下文切换</p>
</li>
</ol>
<p><strong>线程切换只有第二步。</strong></p>
<p><strong>进程间切换步骤总结</strong>：</p>
<ol>
<li>保存当前进程的硬件上下文（即现场）</li>
<li>修改当前进程的 PCB，比如将其状态由运行改为就绪或是等待，并将该进程 PCB 加入相关队列</li>
<li>调度另外一个进程</li>
<li>修改被调度进程的 PCB，将其状态改为运行</li>
<li>将“当前进程”的存储管理数据改为“被调度进程”的存储管理信息（如页表、TLB）</li>
<li>恢复新进程的硬件上下文（即现场），让 PC 指向新进程代码</li>
</ol>
<h3 id="ASCII、Unicode 和 UTF-8 编码的区别？">ASCII、Unicode 和 UTF-8 编码的区别？</h3>
<p>它们的作用是在字符或者汉字和二进制文件中的 01 二进制码进行映射，从而实现用机器二进制码表示字符汉字的效果。</p>
<ul>
<li>ASCII 是一个字符对应一个字节；</li>
<li>Unicode 一个字符对应两个字节；</li>
<li>UTF-8 是一个字符对应可变的字节数，从而大大节省空间。</li>
</ul>
<p>一般内存还有记事本中的存储方式都是 Unicode，硬盘或者文件的存储方式是 UTF-8。</p>
<h3 id="并发、并行、异步的区别">并发、并行、异步的区别</h3>
<ul>
<li><strong>并发</strong>：在一个时间段中同时有多个程序在运行，但其实任一时刻，只有一个程序在 CPU 上运行，宏观上的并发是通过不断的切换实现的；</li>
<li><strong>多线程</strong>：并发运行的一段代码。是实现异步的手段</li>
<li><strong>并行（和串行相比）</strong>：在多 CPU 系统中，多个程序无论宏观还是微观上都是同时执行的。假设目前 A，B 两个进程，两个进程分别由不同的 CPU 管理执行，两个进程不抢占 CPU 资源且可以 <strong> 同时运行</strong>，这叫做并行。</li>
<li><strong>异步（和同步相比）</strong>：同步是顺序执行，异步是在等待某个资源的时候继续做自己的事</li>
</ul>
<h3 id="进程有哪几种状态">进程有哪几种状态</h3>
<ul>
<li><strong>就绪状态</strong>：进程已获得除处理器以外的所需资源，等待分配处理器资源</li>
<li><strong>运行状态</strong>：占用处理器资源运行，处于此状态的进程数小于等于 CPU 数</li>
<li><strong>阻塞状态</strong>： 进程等待某种条件，在条件满足之前无法执行</li>
</ul>
<img src="https://tva1.sinaimg.cn/large/008i3skNly1gz56vtc8kij30rc0hs40n.jpg" alt="image-20220207195017156" style="zoom:50%;" />
<h3 id="什么是文件描述符">什么是文件描述符</h3>
<p>文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。</p>
<p>内核通过文件描述符来访问文件。文件描述符指向一个文件。</p>
<h3 id="什么是用户态和内核态">什么是用户态和内核态</h3>
<p>为了限制不同程序的访问能力，防止一些程序访问其它程序的内存数据，CPU 划分了用户态和内核态两个权限等级。</p>
<ul>
<li>用户态只能受限地访问内存，且不允许访问外围设备，没有占用 CPU 的能力，CPU 资源可以被其它程序获取；</li>
<li>内核态可以访问内存所有数据以及外围设备，也可以进行程序的切换。</li>
</ul>
<p>所有用户程序都运行在用户态，但有时需要进行一些内核态的操作，比如从硬盘或者键盘读数据，这时就需要进行系统调用，使用陷阱指令，CPU 切换到内核态，执行相应的服务，再切换为用户态并返回系统调用的结果。</p>
<ol>
<li><strong>为什么要分用户态和内核态？</strong></li>
</ol>
<ul>
<li><strong>安全性</strong>：防止用户程序恶意或者不小心破坏系统 / 内存 / 硬件资源；</li>
<li><strong>封装性</strong>：用户程序不需要实现更加底层的代码；</li>
<li><strong>利于调度</strong>：如果多个用户程序都在等待键盘输入，这时就需要进行调度；统一交给操作系统调度更加方便。</li>
</ul>
<ol start="2">
<li><strong>如何从用户态切换到内核态？</strong></li>
</ol>
<ul>
<li><strong>系统调用</strong>：比如读取命令行输入。本质上还是通过中断实现</li>
<li><strong>用户程序发生异常时</strong>：比如缺页异常</li>
<li><strong>外围设备的中断</strong>：外围设备完成用户请求的操作之后，会向 CPU 发出中断信号，这时 CPU 会转去处理对应的中断处理程序</li>
</ul>
<h3 id="分页和分段有什么区别">分页和分段有什么区别</h3>
<ol>
<li><strong>页式存储</strong>：是一种用户视角内存与物理内存相分离的内存分配管理方案。用户空间划分为大小相等的部分称为页（page），内存空间划分为同样大小的区域称为页框，分配时以页为单位，按进程需要的页数分配，逻辑上相邻的页物理上不一定相邻；</li>
<li><strong>段式存储</strong>：是一种符合用户视角的内存分配管理方案。用户进程地址空间按照自身逻辑关系划分为若干个段（segment）（如代码段，数据段，堆栈段），内存空间被动态划分为长度不同的区域，分配时以段为单位，每段在内存中占据连续空间，各段可以不相邻；</li>
<li><strong>段页式存储</strong>：用户进程先按段划分，段内再按页划分，内存划分和分配按页。</li>
</ol>
<p><strong>区别</strong>：</p>
<ul>
<li><strong>目的不同</strong>：分页是由于系统管理的需要而不是用户的需要，它是信息的物理单位；分段的目的是为了能更好地满足用户的需要，它是信息的逻辑单位，它含有一组其意义相对完整的信息；</li>
<li><strong>大小不同</strong>：段的大小不固定，由其所完成的功能决定；页的大小固定，由系统决定；</li>
<li><strong>地址空间维度不同</strong>：分段是二维地址空间（段号 + 段内偏移），分页是一维地址空间（每个进程一个页表 / 多级页表，通过一个逻辑地址就能找到对应的物理地址）；</li>
<li><strong>信息共享</strong>：分段便于信息的保护和共享；分页的共享受到限制；</li>
<li><strong>内存碎片</strong>：分段没有内碎片，但会产生外碎片；分页没有外碎片，但会产生内碎片（一个页填不满）</li>
</ul>
<h3 id="什么是颠簸现象">什么是颠簸现象</h3>
<p>颠簸本质上是指频繁的页调度行为。进程发生缺页中断时必须置换某一页。然而，其他所有的页都在使用，它置换一个页，但又立刻再次需要这个页。因此会不断产生缺页中断，导致整个系统的效率急剧下降，这种现象称为颠簸。内存颠簸的解决策略包括：</p>
<ul>
<li>修改页面置换算法；</li>
<li>降低同时运行的程序的数量；</li>
<li>终止该进程或增加物理内存容量。</li>
</ul>
<h3 id="什么是局部性原理">什么是局部性原理</h3>
<ul>
<li><strong>时间上的局部性</strong>：最近被访问的页在不久的将来还会被访问；</li>
<li><strong>空间上的局部性</strong>：内存中被访问的页周围的页也很可能被访问。</li>
</ul>
<h3 id="什么是缓冲区溢出？有什么危害？">什么是缓冲区溢出？有什么危害？</h3>
<ul>
<li>缓冲区溢出是指当计算机向缓冲区内填充数据时超过了缓冲区本身的容量，溢出的数据覆盖在合法数据上</li>
<li>合法数据会被覆盖</li>
</ul>
<h3 id="堆和栈的区别？">堆和栈的区别？</h3>
<ol>
<li>
<p><strong>管理方式不同</strong>。</p>
<ul>
<li>栈由操作系统 <strong> 自动分配释放</strong>；</li>
<li><strong>堆的申请和释放工作由程序员控制 </strong>；(操作系统有一个<strong> 记录空闲内存地址的链表</strong>，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆节点，然后将该节点从空闲节点链表中删除，并将该节点的空间分配给程序。)</li>
</ul>
</li>
<li>
<p><strong>生长方向不同</strong>。</p>
<ul>
<li>堆的生长方向向上，内存地址由低到高；</li>
<li>栈的生长方向向下，内存地址由高到低。</li>
</ul>
</li>
<li>
<p><strong>存放内容不同</strong>。</p>
<ul>
<li>
<p>栈：存放的内容是 <strong> 函数返回地址、相关参数、局部变量和寄存器内容等</strong>。当主函数调用另外一个函数的时候，要对当前函数执行断点进行保存。</p>
</li>
<li>
<p>堆：一般情况堆顶使用一个字节的空间来存放堆的大小，而堆中具体存放内容是由程序员来填充的。</p>
</li>
</ul>
</li>
<li>
<p><strong>空间大小不同 </strong>。每个进程拥有的<strong> 栈的大小要远远小于堆的大小</strong>。理论上，程序员可申请的堆大小为虚拟内存的大小，进程栈的大小 64bits 的 Windows 默认 1MB，64bits 的 Linux 默认 10MB；</p>
</li>
<li>
<p><strong>分配效率不同</strong>。</p>
<ul>
<li>栈由操作系统自动分配，会在硬件层级对栈提供支持：<strong>分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行</strong>，这就决定了栈的效率比较高。</li>
<li>堆则是由 C/C++ 提供的库函数或运算符来完成申请与管理，实现机制较为复杂，频繁的内存申请容易产生内存碎片。显然，堆的效率比栈要低得多。</li>
</ul>
</li>
<li>
<p><strong>分配方式不同</strong>。</p>
<ul>
<li>堆都是动态分配的，没有静态分配的堆。</li>
<li>栈有 2 种分配方式：静态分配和动态分配。
<ul>
<li>静态分配是由操作系统完成的，比如局部变量的分配。</li>
<li><strong>动态分配由 alloca 函数进行分配</strong> (alloca() 不具可移植性，而且在没有传统堆栈的机器上很难实现，所以没有普及)，但是栈的动态分配和堆是不同的，他的动态分配是由操作系统进行释放，无需我们手工实现。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="什么是操作系统">什么是操作系统</h3>
<p>操作系统是运行在计算机上最重要的一种 <code> 软件</code>，它管理计算机的资源和进程以及所有的硬件和软件。它为计算机硬件和软件提供了一种中间层</p>
<img src="https://tva1.sinaimg.cn/large/008i3skNly1gz72xaxyazj31kk0r0acy.jpg" alt="image-20220209110423657" style="zoom:50%;" />
<p>通常情况下，计算机上会运行着许多应用程序，它们都需要对内存和 CPU 进行交互，操作系统的目的就是为了保证这些访问和交互能够准确无误的进行。</p>
<h3 id="操作系统的主要目的">操作系统的主要目的</h3>
<p>操作系统是一种软件，它的主要目的有三种</p>
<ul>
<li>管理计算机资源，这些资源包括 CPU、内存、磁盘驱动器、打印机等。</li>
<li>提供一种图形界面，就像我们前面描述的那样，它提供了用户和计算机之间的桥梁。</li>
<li>为其他软件提供服务，操作系统与软件进行交互，以便为其分配运行所需的任何必要资源。</li>
</ul>
<h3 id="操作系统的种类有哪些">操作系统的种类有哪些</h3>
<ol>
<li>批处理操作系统(Batch Processing Operation System)；</li>
<li>分时操作系统(Time Sharing Operating System)；</li>
<li>实时操作系统(Real Time Operating System)；</li>
<li>个人操作系统(Personal Operating System)；</li>
<li>网络操作系统(NOS, Network Operating System)；</li>
<li>分布式操作系统(Distributed Operating System)。</li>
</ol>
<h3 id="多处理系统的优势">多处理系统的优势</h3>
<p>随着处理器的不断增加，我们的计算机系统由单机系统变为了多处理系统，多处理系统的吞吐量比较高，多处理系统拥有多个并行的处理器，这些处理器共享时钟、内存、总线、外围设备等。</p>
<img src="https://tva1.sinaimg.cn/large/008i3skNly1gz732edxkjj31ly0n475v.jpg" alt="image-20220209110920619" style="zoom:33%;" />
<p>多处理系统由于可以共享资源，因此可以开源节流，省钱。整个系统的可靠性也随之提高。</p>
<h3 id="什么是内核">什么是内核</h3>
<p>操作系统最直观的感受就是桌面系统，以及上层的应用程序，而后面的资源处理等等就是操作系统背后的 <strong> 黑盒</strong>。</p>
<p>“内核”指的是一个提供硬件抽象层、磁盘及文件系统控制、多任务等功能的系统软件。<strong>内核是操作系统最基本的部分</strong>。它是为众多应用程序提供对计算机硬件的安全访问的一部分软件，这种访问是有限的，并且内核决定一个程序在什么时候对某部分硬件操作多长时间。直接对硬件操作是非常复杂的，所以内核通常提供一种硬件抽象的方法来完成这些操作。硬件抽象隐藏了复杂性，为应用软件和硬件提供了一套简洁，统一的接口，使程序设计更为简单。</p>
<p>简单来说，内核是一个操作系统的核心。它负责管理系统的进程、内存、设备驱动程序、文件和网络系统等等，决定着系统的性能和稳定性。是连接应用程序和硬件的桥梁。内核就是操作系统背后 <strong> 黑盒的核心</strong>。</p>
<img src="https://s2.loli.net/2022/03/24/a1CRp4W9KbHLcxV.png" alt="image-20220324101227398" style="zoom:50%;" />
<h3 id="内核的分类">内核的分类</h3>
<p>现在内核的主要分类有四类：宏内核（单内核），微内核，混合内核，外内核。</p>
<ul>
<li><strong>宏内核</strong>：内核管理着操作系统的内存，文件，IO，网络等等，每个功能可以看做一个模块，在宏内核中，这些模块都是集成在一起的，运行在内核进程中，模块之间的交互直接通过方法调用。</li>
</ul>
<img src="https://s2.loli.net/2022/03/24/xCsjIGTe7ki1ZvS.png" alt="image-20220324101525260" style="zoom:50%;" />
<ul>
<li><strong>微内核</strong>：内核只提供最核心的功能，比如任务调度，内存管理等等，其他模块被移出内核，运行在不同的进程中，这样即使某一个模块出现问题，只要重启这个模块的进程即可，不会影响到其他模块，稳定性大大增加。甚至可以在系统运行过程中替换现有模块的实现。而且由于模块独立的性质，可以做到模块的按需加载。但是模块间的相互调用需要通过进程间通信，通信效率相对较低。</li>
</ul>
<img src="https://s2.loli.net/2022/03/24/aGu7gyEVFB34TAt.png" alt="image-20220324101615970" style="zoom:50%;" />
<ul>
<li><strong>混合内核</strong>：宏内核和微内核的实现，两者各有千秋，也各有缺点，所以混合内核就是集中了两者的特点，让微内核中的一些核心模块运行在内核中，从而使内核效率更高一些。</li>
<li><strong>外内核</strong>：外内核是把硬件暴露给应用程序，应用程序可以直接访问硬件，外内核对系统提供保护。目前还在研究阶段。</li>
</ul>
<p><strong>宏内核与微内核的对比</strong>：</p>
<table>
<thead>
<tr>
<th></th>
<th>宏内核</th>
<th>微内核</th>
</tr>
</thead>
<tbody>
<tr>
<td>通信效率</td>
<td>高（函数调用）</td>
<td>低（进程间通信）</td>
</tr>
<tr>
<td>稳定性</td>
<td>低（模块集成在一起）</td>
<td>高（模块间互不影响）</td>
</tr>
<tr>
<td>扩展性</td>
<td>低（模块集成在一起）</td>
<td>高（模块间互不影响）</td>
</tr>
<tr>
<td>代码量</td>
<td>多（需要实现所有模块）</td>
<td>少（只需要实现核心功能）</td>
</tr>
</tbody>
</table>
<p><strong>当前主流操作系统内核</strong>：</p>
<p><strong>宏内核</strong></p>
<ul>
<li>Linux</li>
<li>Windows 9X 系列</li>
<li>MacOS 8.6 版本之前</li>
</ul>
<p><strong>微内核</strong></p>
<ul>
<li>Fuchsia</li>
<li>鸿蒙</li>
<li>Minix</li>
</ul>
<p><strong>混合内核</strong></p>
<ul>
<li>Windows XP</li>
<li>Windows 7</li>
<li>Mac OS X</li>
<li>XNU</li>
</ul>
<p><strong>外内核</strong></p>
<ul>
<li>Nemesis</li>
</ul>
<h3 id="内核的特征">内核的特征</h3>
<p><strong>并发</strong><br>
计算机系统中 <strong> 一段 </strong> 时间内同时存在多个运行的程序，需要 OS 管理和调度</p>
<ul>
<li>并发是指宏观上在一段时间内能同时运行多个程序，而并行则指同一时刻能运行多个指令。</li>
<li>并行需要硬件支持，如多流水线、多核处理器或者分布式计算系统。</li>
</ul>
<p><strong>共享</strong><br>
系统中的资源可以被多个并发进程共同使用。</p>
<ul>
<li><strong>同时 </strong> 访问</li>
<li><strong>互斥 </strong> 共享</li>
</ul>
<p><strong>虚拟</strong><br>
利用多道程序设计技术，让每个用户都觉得有一个计算机专门为他服务</p>
<ul>
<li>时分复用技术。如处理机交替为进程服务</li>
<li>空分复用技术。如虚拟存储技术</li>
</ul>
<p><strong>异步</strong></p>
<ul>
<li>程序的执行不是一贯到底，而是走走停停，向前推进的速度不可预知</li>
<li>但只要运行环境相同，OS 需要保证程序运行的 <strong> 结果也要相同</strong></li>
</ul>
<h3 id="虚拟内存与物理内存的联系与区别">虚拟内存与物理内存的联系与区别</h3>
<p>操作系统有虚拟内存与物理内存的概念。在很久以前，还没有虚拟内存概念的时候，程序寻址用的都是物理地址。程序能寻址的范围是有限的，这取决于 CPU 的地址线条数。比如在 32 位平台下，寻址的范围是 $2^{32} $ 也就是 4G。并且这是固定的，如果没有虚拟内存，且每次开启一个进程都给 4G 的物理内存，就可能会出现很多问题：</p>
<ul>
<li>因为我的 <strong> 物理内存是有限的</strong>，当有多个进程要执行的时候，都要给 4G 内存，很显然你内存小一点，这很快就分配完了，于是没有得到分配资源的进程就只能等待。当一个进程执行完了以后，再将等待的进程装入内存。这种频繁的装入内存的操作是很没效率的</li>
<li>由于指令都是 <strong> 直接访问物理内存 </strong> 的，那么我这个进程就可以修改其他进程的数据，甚至会修改内核地址空间的数据，这是我们不想看到的</li>
<li>因为内存是 <strong> 随机分配 </strong> 的，所以程序运行的地址也是不正确的。</li>
</ul>
<p>于是针对上面会出现的各种问题，虚拟内存就出来了。</p>
<p>一个进程运行时都会得到 4G 的虚拟内存。这个虚拟内存你可以认为，每个进程都认为自己拥有 4G 的空间，这只是每个进程认为的，但是实际上，在虚拟内存对应的物理内存上，可能只对应的一点点的物理内存，<strong>实际用了多少内存，就会对应多少物理内存</strong>。</p>
<p>进程得到的这 4G 虚拟内存是一个 <strong> 连续的地址空间（这也只是进程认为），而实际上，它通常是被分隔成多个物理内存碎片，还有一部分存储在外部磁盘存储器上，在需要时进行数据交换。</strong></p>
<p>进程开始要访问一个地址，它可能会经历下面的过程：</p>
<ol>
<li>每次我要访问地址空间上的某一个地址，都需要把地址翻译为实际物理内存地址</li>
<li>所有进程共享这整一块物理内存，每个进程只把自己目前需要的虚拟地址空间映射到物理内存上</li>
<li>进程需要知道哪些地址空间上的数据在物理内存上，哪些不在（可能这部分存储在磁盘上），还有在物理内存上的哪里，这就需要通过 <strong> 页表 </strong> 来记录</li>
<li>页表的每一个表项分两部分，第一部分记录 <strong> 此页是否在物理内存上 </strong>，第二部分记录<strong> 物理内存页的地址</strong>（如果在的话）</li>
<li>当进程访问某个虚拟地址的时候，就会先去看页表，如果发现对应的数据不在物理内存上，就会发生 <strong> 缺页异常</strong></li>
<li>缺页异常的处理过程，操作系统立即 <strong> 阻塞 </strong> 该进程，并将硬盘里对应的页换入内存，然后使该进程就绪，如果内存已经满了，没有空地方了，那就找一个页覆盖，至于具体覆盖的哪个页，就需要看操作系统的页面置换算法是怎么设计的了。</li>
</ol>
<p>关于虚拟内存与物理内存的联系，下面这张图可以帮助我们巩固。</p>
<img src="https://tva1.sinaimg.cn/large/e6c9d24egy1gzmjzc5ycvj21gm0u079b.jpg" alt="image-20220222201800815" style="zoom: 33%;" />
<p><strong>页表的工作原理如下图</strong></p>
<img src="https://tva1.sinaimg.cn/large/e6c9d24egy1gzmk0rnha7j21hq0twgqk.jpg" alt="image-20220222201925561" style="zoom:33%;" />
<ol>
<li>我们的 CPU 想访问虚拟地址所在的虚拟页(VP3)，根据页表，找出页表中第三条的值. 判断有效位。 如果有效位为 1，DRMA 缓存命中，根据物理页号，找到物理页当中的内容，返回。</li>
<li>若有效位为 0，产生 <strong> 缺页异常</strong>，调用内核缺页异常处理程序。内核通过页面置换算法选择一个页面作为被覆盖的页面，将该页的内容刷新到磁盘空间当中。然后把 VP3 映射的磁盘文件缓存到该物理页上面。然后页表中第三条，有效位变成 1，第二部分存储上了可以对应物理内存页的地址的内容。</li>
<li>缺页异常处理完毕后，返回中断前的指令，<strong>重新执行</strong>，此时缓存命中，执行 1。</li>
<li>将找到的内容映射到告诉缓存当中，CPU 从告诉缓存中获取该值，结束。</li>
</ol>
<p><strong>虚拟内存工作总结</strong></p>
<p>当每个进程创建的时候，内核会为进程分配 4G 的虚拟内存，当进程还没有开始运行时，这只是一个内存布局。实际上并不立即就把虚拟内存对应位置的程序数据和代码（比如.text .data 段）拷贝到物理内存中，只是建立好虚拟内存和磁盘文件之间的映射就好（叫做存储器映射）。这个时候数据和代码还是在磁盘上的。当运行到对应的程序时，进程去寻找页表，发现页表中地址没有存放在物理内存上，而是在磁盘上，于是发生缺页异常，于是将磁盘上的数据拷贝到物理内存中。</p>
<p>另外在进程运行过程中，要通过 malloc 来动态分配内存时，也只是分配了虚拟内存，即为这块虚拟内存对应的页表项做相应设置，当进程真正访问到此数据时，才引发缺页异常。</p>
<p>可以认为虚拟空间都被映射到了磁盘空间中（事实上也是按需要映射到磁盘空间上，通过 mmap，mmap 是用来建立虚拟空间和磁盘空间的映射关系的）</p>
<p><strong>利用虚拟内存机制的优点</strong></p>
<ol>
<li>既然每个进程的内存空间都是一致而且固定的（32 位平台下都是 4G），所以链接器在链接可执行文件时，可以设定内存地址，而不用去管这些数据最终实际内存地址，这交给 <strong> 内核来完成映射关系</strong></li>
<li>当不同的进程使用同一段代码时，比如库文件的代码，在物理内存中可以 <strong> 只存储一份这样的代码</strong>，不同进程只要将自己的虚拟内存映射过去就好了，这样可以节省物理内存</li>
<li>在程序需要分配连续空间的时候，只需要在虚拟内存分配连续空间，而 <strong> 不需要物理内存连续 </strong> 的，实际上，往往物理内存都是断断续续的内存碎片。这样就可以有效地利用我们的物理内存</li>
</ol>
</article><div class="tag_share"><div class="post_share"><div class="social-share" data-image="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.</span> <span class="toc-text">进程和线程的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">2.</span> <span class="toc-text">进程间通信的方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E4%BA%8E%20socket%20%E9%80%9A%E4%BF%A1%EF%BC%8C%E7%BD%91%E7%BB%9C%E5%A5%97%E6%8E%A5%E5%AD%97%E5%92%8C%20Unix%20%E5%9F%9F%E5%A5%97%E6%8E%A5%E5%AD%97%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">3.</span> <span class="toc-text">对于 socket 通信，网络套接字和 Unix 域套接字的区别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E9%97%B4%E5%90%8C%E6%AD%A5%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%884%20%E7%A7%8D%E5%B8%B8%E7%94%A8%E6%96%B9%E5%BC%8F%EF%BC%89"><span class="toc-number">4.</span> <span class="toc-text">线程间同步的方式（4 种常用方式）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%B4%E7%95%8C%E5%8C%BA%E5%92%8C%E4%BA%92%E6%96%A5%E9%87%8F%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">5.</span> <span class="toc-text">临界区和互斥量区别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%90%84%E8%87%AA%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">6.</span> <span class="toc-text">多进程和多线程各自的应用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%80%E5%AE%9A%E6%AF%94%E5%8D%95%E7%BA%BF%E7%A8%8B%E5%A5%BD%E5%90%97%EF%BC%9F"><span class="toc-number">7.</span> <span class="toc-text">多线程一定比单线程好吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">8.</span> <span class="toc-text">调度算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98"><span class="toc-number">9.</span> <span class="toc-text">虚拟内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E9%9C%80%E8%A6%81%E7%BB%8F%E8%BF%87%E5%93%AA%E5%87%A0%E4%B8%AA%E6%AD%A5%E9%AA%A4"><span class="toc-number">10.</span> <span class="toc-text">程序运行需要经过哪几个步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E9%94%81%E5%92%8C%E8%AF%BB%E5%86%99%E9%94%81%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">11.</span> <span class="toc-text">互斥锁和读写锁的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%8F%91%E7%94%9F%E6%AD%BB%E9%94%81"><span class="toc-number">12.</span> <span class="toc-text">为什么会发生死锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E9%A2%84%E9%98%B2"><span class="toc-number">13.</span> <span class="toc-text">死锁预防</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81"><span class="toc-number">14.</span> <span class="toc-text">怎么避免死锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%94%BE%E5%9C%A8%E5%86%85%E5%AD%98%E7%9A%84%E4%BD%8E%E5%9C%B0%E5%9D%80%E8%BF%98%E6%98%AF%E9%AB%98%E5%9C%B0%E5%9D%80%EF%BC%9F"><span class="toc-number">15.</span> <span class="toc-text">操作系统放在内存的低地址还是高地址？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%BB%8F%E5%B8%B8%E5%9C%A8%E5%86%85%E5%AD%98%E5%92%8C%E7%A3%81%E7%9B%98%E9%97%B4%E6%8D%A2%E5%85%A5%E6%8D%A2%E5%87%BA%EF%BC%8C%E6%80%8E%E6%A0%B7%E4%BF%9D%E8%AF%81%E6%AF%8F%E6%AC%A1%E6%8D%A2%E5%85%A5%E6%8D%A2%E5%87%BA%E5%90%8E%E8%BF%9B%E7%A8%8B%E4%B8%AD%E7%9A%84%E6%8C%87%E4%BB%A4%E8%B7%B3%E8%BD%AC%E7%9A%84%E5%9C%B0%E5%9D%80%E4%B8%8D%E4%BC%9A%E6%B7%B7%E4%B9%B1%EF%BC%9F"><span class="toc-number">16.</span> <span class="toc-text">进程经常在内存和磁盘间换入换出，怎样保证每次换入换出后进程中的指令跳转的地址不会混乱？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%86%85%E5%AD%98%E6%AF%94%E7%A3%81%E7%9B%98%E5%BF%AB%EF%BC%9F"><span class="toc-number">17.</span> <span class="toc-text">为什么内存比磁盘快？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E5%88%87%E6%8D%A2%E5%92%8C%E7%BA%BF%E7%A8%8B%E9%97%B4%E7%9A%84%E5%88%87%E6%8D%A2"><span class="toc-number">18.</span> <span class="toc-text">进程间的切换和线程间的切换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ASCII%E3%80%81Unicode%20%E5%92%8C%20UTF-8%20%E7%BC%96%E7%A0%81%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">19.</span> <span class="toc-text">ASCII、Unicode 和 UTF-8 编码的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E3%80%81%E5%B9%B6%E8%A1%8C%E3%80%81%E5%BC%82%E6%AD%A5%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">20.</span> <span class="toc-text">并发、并行、异步的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E7%8A%B6%E6%80%81"><span class="toc-number">21.</span> <span class="toc-text">进程有哪几种状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-number">22.</span> <span class="toc-text">什么是文件描述符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81"><span class="toc-number">23.</span> <span class="toc-text">什么是用户态和内核态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E9%A1%B5%E5%92%8C%E5%88%86%E6%AE%B5%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">24.</span> <span class="toc-text">分页和分段有什么区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%A2%A0%E7%B0%B8%E7%8E%B0%E8%B1%A1"><span class="toc-number">25.</span> <span class="toc-text">什么是颠簸现象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%B1%80%E9%83%A8%E6%80%A7%E5%8E%9F%E7%90%86"><span class="toc-number">26.</span> <span class="toc-text">什么是局部性原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E5%8D%B1%E5%AE%B3%EF%BC%9F"><span class="toc-number">27.</span> <span class="toc-text">什么是缓冲区溢出？有什么危害？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E5%92%8C%E6%A0%88%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">28.</span> <span class="toc-text">堆和栈的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-number">29.</span> <span class="toc-text">什么是操作系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%B8%BB%E8%A6%81%E7%9B%AE%E7%9A%84"><span class="toc-number">30.</span> <span class="toc-text">操作系统的主要目的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%A7%8D%E7%B1%BB%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">31.</span> <span class="toc-text">操作系统的种类有哪些</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E5%A4%84%E7%90%86%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-number">32.</span> <span class="toc-text">多处理系统的优势</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E6%A0%B8"><span class="toc-number">33.</span> <span class="toc-text">什么是内核</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">34.</span> <span class="toc-text">内核的分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E7%9A%84%E7%89%B9%E5%BE%81"><span class="toc-number">35.</span> <span class="toc-text">内核的特征</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E4%B8%8E%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%9A%84%E8%81%94%E7%B3%BB%E4%B8%8E%E5%8C%BA%E5%88%AB"><span class="toc-number">36.</span> <span class="toc-text">虚拟内存与物理内存的联系与区别</span></a></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2022 By 陈泽豪</div><div class="footer_custom_text">我是豪豪</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex@latest/dist/contrib/copy-tex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/contrib/copy-tex.css"><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script><script>(() => {
  const $mermaidWrap = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaidWrap.length) {
    window.runMermaid = () => {
      window.loadMermaid = true
      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

      Array.from($mermaidWrap).forEach((item, index) => {
        const mermaidSrc = item.firstElementChild
        const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
        const mermaidID = 'mermaid-' + index
        const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent
        mermaid.mermaidAPI.render(mermaidID, mermaidDefinition, (svgCode) => {
          mermaidSrc.insertAdjacentHTML('afterend', svgCode)
        })
      })
    }

    const loadMermaid = () => {
      window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
    }

    window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
  }
})()</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script></div></body></html>
<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>1- 计算机网络常见知识点 | 陈泽豪</title><meta name="author" content="陈泽豪"><meta name="copyright" content="陈泽豪"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="当键入网址后，到网页显示，期间发生了什么 这篇文章写的很好，但是很长 探究！一个数据包在网络中的心路历程 总结一下：  DNS 解析： 浏览器查询 DNS，获取域名对应的 IP 地址：具体过程包括浏览器搜索自身的 DNS 缓存、搜索操作系统的 DNS 缓存、读取本地的 Host 文件和向本地 DNS 服务器进行查询等。对于向本地 DNS 服务器进行查询，如果要查询的域名包含在本地配置区域资源中，则">
<meta property="og:type" content="article">
<meta property="og:title" content="1- 计算机网络常见知识点">
<meta property="og:url" content="https://chenzehao.com/18772.html">
<meta property="og:site_name" content="陈泽豪">
<meta property="og:description" content="当键入网址后，到网页显示，期间发生了什么 这篇文章写的很好，但是很长 探究！一个数据包在网络中的心路历程 总结一下：  DNS 解析： 浏览器查询 DNS，获取域名对应的 IP 地址：具体过程包括浏览器搜索自身的 DNS 缓存、搜索操作系统的 DNS 缓存、读取本地的 Host 文件和向本地 DNS 服务器进行查询等。对于向本地 DNS 服务器进行查询，如果要查询的域名包含在本地配置区域资源中，则">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7">
<meta property="article:published_time" content="2021-06-04T16:00:00.000Z">
<meta property="article:modified_time" content="2022-03-24T07:32:36.710Z">
<meta property="article:author" content="陈泽豪">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"><link rel="shortcut icon" href="https://tva1.sinaimg.cn/large/008i3skNgy1gyk8f9yfnqj305k05kglg.jpg"><link rel="canonical" href="https://chenzehao.com/18772"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><meta name="baidu-site-verification" content="code-GhGfwpqKHn"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?9191e58322566f7fdcbb360b8eeb1686";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'mediumZoom',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '1- 计算机网络常见知识点',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-03-24 15:32:36'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.0.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gyk8f9yfnqj305k05kglg.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">84</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">23</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><span> 笔记</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">陈泽豪</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><span> 笔记</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">1- 计算机网络常见知识点</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-06-04T16:00:00.000Z" title="发表于 2021-06-05 00:00:00">2021-06-05</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-03-24T07:32:36.710Z" title="更新于 2022-03-24 15:32:36">2022-03-24</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">13.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>42分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h3 id="当键入网址后，到网页显示，期间发生了什么">当键入网址后，到网页显示，期间发生了什么</h3>
<p>这篇文章写的很好，但是很长</p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/iSZp41SRmh5b2bXIvzemIw">探究！一个数据包在网络中的心路历程</a></p>
<p>总结一下：</p>
<ol>
<li><strong>DNS 解析：</strong> 浏览器查询 DNS，获取域名对应的 IP 地址：具体过程包括浏览器搜索自身的 DNS 缓存、搜索操作系统的 DNS 缓存、读取本地的 Host 文件和向本地 DNS 服务器进行查询等。对于向本地 DNS 服务器进行查询，如果要查询的域名包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析(此解析具有权威性)；如果要查询的域名不由本地 DNS 服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个 IP 地址映射，完成域名解析（此解析不具有权威性）。如果本地域名服务器并未缓存该网址映射关系，那么将根据其设置发起递归查询或者迭代查询</li>
<li><strong>TCP 连接：</strong> 浏览器获得域名对应的 IP 地址以后，浏览器向服务器请求建立链接，发起三次握手</li>
<li><strong>发送 HTTP 请求：</strong> TCP 连接建立起来后，浏览器向服务器发送 HTTP 请求</li>
<li><strong>服务器处理请求并返回 HTTP 报文：</strong> 服务器接收到这个请求，并根据路径参数映射到特定的请求处理器进行处理，并将处理结果及相应的视图返回给浏览器</li>
<li><strong>浏览器解析渲染页面：</strong> 浏览器解析并渲染视图，若遇到对 js 文件、css 文件及图片等静态资源的引用，则重复上述步骤并向服务器请求这些资源；浏览器根据其请求到的资源、数据渲染页面，最终向用户呈现一个完整的页面</li>
<li><strong>连接结束</strong></li>
</ol>
<h3 id="地址解析协议 ARP-Address-Resolution-Protocol">地址解析协议 ARP(Address Resolution Protocol)</h3>
<p>网络层实现主机之间的通信，而链路层实现具体每段链路之间的通信。因此在通信过程中，IP 数据报的源地址和目的地址始终不变，而 MAC 地址随着链路的改变而改变。</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gz1ndjgdecj319u09wq4i.jpg" alt="image-20220204181833588"></p>
<p>ARP 实现由 IP 地址得到 MAC 地址。</p>
<img src="https://tva1.sinaimg.cn/large/008i3skNly1gz1ndx884yj30vu0fk0uv.jpg" alt="image-20220204181900725" style="zoom: 50%;" />
<p>每个主机都有一个 ARP 高速缓存，里面有本局域网上的各主机和路由器的 IP 地址到 MAC 地址的映射表。</p>
<p>如果主机 A 知道主机 B 的 IP 地址，但是 ARP 高速缓存中没有该 IP 地址到 MAC 地址的映射，此时主机 A 通过广播的方式发送 ARP 请求分组，主机 B 收到该请求后会发送 ARP 响应分组给主机 A 告知其 MAC 地址，随后主机 A 向其高速缓存中写入主机 B 的 IP 地址到 MAC 地址的映射。</p>
<img src="https://tva1.sinaimg.cn/large/008i3skNly1gz1nezyhe9j310k0u0gpu.jpg" alt="image-20220204182001736" style="zoom:50%;" />
<h3 id="网际控制报文协议 ICMP-Internet-Control-Message-Protocol">网际控制报文协议 ICMP(Internet Control Message Protocol)</h3>
<p>ICMP 协议在网络层，所以也作用在网络层。</p>
<p>ICMP 是为了更有效地转发 IP 数据报和提高交付成功的机会。它封装在 IP 数据报中，但是不属于高层协议。</p>
<p>ICMP 协议主要作用：</p>
<ol>
<li>查看 IP 数据包是否成功发送到对端。</li>
<li>传输出错的时候，返回错误信息。</li>
<li>改善网络设置。</li>
</ol>
<p>ICMP 报文分为差错报告报文和询问报文。</p>
<img src="https://tva1.sinaimg.cn/large/008i3skNly1gz1qy70f8wj31ks0msjvv.jpg" alt="image-20220204202216984" style="zoom:50%;" />
<ol>
<li>
<p><strong>Ping</strong></p>
<p>Ping 是 ICMP 的一个重要应用，主要用来测试两台主机之间的连通性。</p>
<p>Ping 的原理是通过向目的主机发送 ICMP Echo 请求报文，目的主机收到之后会发送 Echo 回答报文。Ping 会根据时间和成功响应的次数估算出数据包往返时间以及丢包率。</p>
</li>
<li>
<p><strong>Traceroute</strong></p>
<p>Traceroute 是 ICMP 的另一个应用，用来跟踪一个分组从源点到终点的路径。</p>
<p>Traceroute 发送的 IP 数据报封装的是无法交付的 UDP 用户数据报，并由目的主机发送终点不可达差错报告报文。</p>
<p>源主机向目的主机发送一连串的 IP 数据报。第一个数据报 P1 的生存时间 TTL 设置为 1，当 P1 到达路径上的第一个路由器 R1 时，R1 收下它并把 TTL 减 1，此时 TTL 等于 0，R1 就把 P1 丢弃，并向源主机发送一个 ICMP 时间超过差错报告报文；<br>
源主机接着发送第二个数据报 P2，并把 TTL 设置为 2。P2 先到达 R1，R1 收下后把 TTL 减 1 再转发给 R2，R2 收下后也把 TTL 减 1，由于此时 TTL 等于 0，R2 就丢弃 P2，并向源主机发送一个 ICMP 时间超过差错报文。<br>
不断执行这样的步骤，直到最后一个数据报刚刚到达目的主机，主机不转发数据报，也不把 TTL 值减 1。但是因为数据报封装的是无法交付的 UDP，因此目的主机要向源主机发送 ICMP 终点不可达差错报告报文。<br>
之后源主机知道了到达目的主机所经过的路由器 IP 地址以及到达每个路由器的往返时间。</p>
</li>
</ol>
<h3 id="交换机和路由器的区别">交换机和路由器的区别</h3>
<ol>
<li><strong>交换机 </strong> 是基于以太网设计的，俗称 <strong> 二层 </strong> 网络设备，交换机的端口不具有 MAC 地址；<strong>路由器 </strong> 是基于 IP 设计的，俗称 <strong> 三层 </strong> 网络设备，路由器的各个端口都具有 MAC 地址和 IP 地址</li>
<li><strong>交换机 </strong> 直接接收缓存；<strong>路由器 </strong> 在接收前需要核对 MAC</li>
<li><strong>交换机 </strong> 通过 MAC 头部中的接收方 MAC 地址根据映射表来判断转发目标；<strong>路由器 </strong> 根据 IP 头部中的 IP 地址查询路由表判断转发目标</li>
</ol>
<h3 id="查询 DNS 服务器的时候，一开始就是从根域名开始查询吗？">查询 DNS 服务器的时候，一开始就是从根域名开始查询吗？</h3>
<p>不是。DNS 本身是有缓存机制的，在缓存有效期内，可以直接从缓存中进行查找，就不一定从根域名开始查询。</p>
<h3 id="拥塞控制算法">拥塞控制算法</h3>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/tuyang1129/p/12439862.html">计算机网络——TCP 的拥塞控制（超详细）</a></p>
<p>TCP 主要通过四个算法来进行拥塞控制：慢开始、拥塞避免、快重传、快恢复。</p>
<p>发送方需要维护一个叫做拥塞窗口（cwnd）的状态变量，注意拥塞窗口与发送方窗口的区别：拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口。</p>
<img src="https://tva1.sinaimg.cn/large/008i3skNly1gz1u5e8qonj31o40nowj0.jpg" alt="image-20220204221300064" style="zoom:50%;" />
<ol>
<li>
<p><strong>慢开始与拥塞避免</strong></p>
<p>发送的最初执行慢开始，令 cwnd = 1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 …</p>
<p>注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能性也就更高。设置一个慢开始门限 ssthresh，当 cwnd &gt;= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。</p>
<p>如果出现了超时，则令 ssthresh = cwnd / 2，然后重新执行慢开始。</p>
</li>
<li>
<p><strong>快重传与快恢复</strong></p>
<p>在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。例如已经接收到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>M</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">M_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.109em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>M</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">M_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.109em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> ，此时收到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>M</mi><mn>4</mn></msub></mrow><annotation encoding="application/x-tex">M_4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.109em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> ，应当发送对<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>M</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">M_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.109em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的确认。</p>
<p>在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例如收到三个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>M</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">M_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.109em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> ，则<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>M</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">M_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.109em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 丢失，立即重传<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>M</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">M_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.109em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。</p>
<p>在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令 ssthresh = cwnd / 2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免。</p>
<p>慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh。</p>
</li>
</ol>
<img src="https://tva1.sinaimg.cn/large/008i3skNly1gz1uapu4byj31hy0u0gqi.jpg" alt="image-20220204221806619" style="zoom:30%;" />
<h3 id="流量控制和拥塞控制的区别">流量控制和拥塞控制的区别</h3>
<ul>
<li>
<p>流量控制解决的是发送方和接收方速率不匹配的问题，发送方发送过快接收方就来不及接收和处理。采用的机制是滑动窗口的机制，控制的是发送了但未被 ACK 的包数量。</p>
</li>
<li>
<p>拥塞控制解决的是避免网络资源被耗尽的问题，通过大家自律的采取避让的措施，来避免网络有限资源被耗尽。当出现丢包时，控制发送的速率达到降低网络负载的目的。</p>
</li>
<li>
<p><strong>流量控制</strong></p>
<ul>
<li>流量控制是通过滑动窗口来实现的。 滑动窗口分为发送端窗口和接收端窗口。</li>
<li>窗口有大小限制，窗口大小是接收端用来告诉发送端目前接收端能接收的最大字节数。</li>
<li>窗口的大小在 TCP 协议头里，大小为 16 位。然而在 TCP 协议的可选项里，还可以定义窗口的比例因子，因此实际的窗口大小可以超过 64KB。窗口的含义实际上就是接收缓冲区的大小。</li>
<li>发送窗口维护了发送端发送的已被接收端 ACK 的序号，以及已经发送的最大序号，这样就可以知道还能发送多少的新数据。</li>
<li>接收窗口维护了已经 ACK 的序号，以及所有接收到的包序号。</li>
<li>窗口大小在特定的一次连接通信过程中，大小是不变的。而滑动窗口是一种机制，滑动窗口的大小在发送端代表的是可发送的数据大小，在接收端代表的是可接收的数据大小，它们是动态变化的。</li>
</ul>
</li>
<li>
<p><strong>拥塞控制</strong></p>
<ul>
<li>拥塞控制是通过拥塞窗口来实现的。拥塞窗口指发送端在一个 RTT 内可以最多发送的数据包数。</li>
<li>拥塞控制一般包括慢启动、拥塞避免两个阶段。</li>
<li>慢启动阶段是从 1 开始指数增长到限定大小的过程。</li>
<li>拥塞避免阶段时超过限定大小之后线性增加的过程，以及发现丢包后将拥塞窗口改为 1，并把限定大小减半的过程。</li>
</ul>
</li>
</ul>
<h3 id="TCP 的三次握手">TCP 的三次握手</h3>
<img src="https://tva1.sinaimg.cn/large/008i3skNly1gz1ukh429lj31ae0u00yn.jpg" alt="image-20220204222727962" style="zoom:33%;" />
<p>假设 A 为客户端，B 为服务器端。</p>
<ul>
<li>首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。</li>
<li>A 向 B 发送连接请求报文，SYN=1，ACK=0，选择一个初始的序号 x。</li>
<li>B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 y。</li>
<li>A 收到 B 的连接确认报文后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。</li>
<li>B 收到 A 的确认后，连接建立。</li>
</ul>
<p><strong>三次握手的原因</strong></p>
<ul>
<li>
<p>第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。<strong>（主要原因）</strong></p>
<p>客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。</p>
</li>
<li>
<p>确认双方的接受与发送能力正常</p>
<p>第一次握手：客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。<br>
第二次握手：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。<br>
第三次握手：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。</p>
</li>
<li>
<p>同步双方的初始序列号</p>
<p>客户端发起连接会有一个序列号，服务器会根据该序列号产生 ack 应答；</p>
<p>同时服务器也产生一个序列号，要求客户端也需要根据服务器的序列号产生相应的 ack 应答。</p>
<p>这样两边的初始序列号就可以同步，否则会造成序列混乱。</p>
</li>
</ul>
<p><strong>三次握手过程中可以携带数据吗？</strong></p>
<p>很多人可能会认为三次握手都不能携带数据，其实第三次握手的时候，是可以携带数据的。也就是说，第一次、第二次握手不可以携带数据，而第三次握手是可以携带数据的。</p>
<p>为什么这样呢？大家可以想一个问题，假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据，因为攻击者根本就不理服务器的接收、发送能力是否正常，然后疯狂着重复发 SYN 报文的话，这会让服务器花费很多时间、内存空间来接收这些报文。也就是说，第一次握手可以放数据的话，其中一个简单的原因就是会让服务器更加容易受到攻击了。</p>
<p>而对于第三次的话，此时客户端已经处于 established 状态，也就是说，对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据。</p>
<h3 id="TCP 的四次握手">TCP 的四次握手</h3>
<img src="https://tva1.sinaimg.cn/large/008i3skNly1gz1v4cw8suj317j0u0wjq.jpg" alt="image-20220204224636168" style="zoom:33%;" />
<p>以下描述不讨论序号和确认号，因为序号和确认号的规则比较简单。并且不讨论 ACK，因为 ACK 在连接建立之后都为 1。</p>
<ul>
<li>A 发送连接释放报文，FIN=1。</li>
<li>B 收到之后发出确认，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。</li>
<li>当 B 不再需要连接时，发送连接释放报文，FIN=1。</li>
<li>A 收到后发出确认，进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接。</li>
<li>B 收到 A 的确认后释放连接。</li>
</ul>
<p><strong>四次挥手的原因</strong></p>
<p>客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。</p>
<p><strong>TIME_WAIT</strong></p>
<p>客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由：</p>
<ul>
<li>确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。</li>
<li>等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。</li>
</ul>
<h3 id="TCP 的重传机制、滑动窗口、流量控制、拥塞控制">TCP 的重传机制、滑动窗口、流量控制、拥塞控制</h3>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/133307545">30 张图解： TCP 重传、滑动窗口、流量控制、拥塞控制发愁</a></p>
<h3 id="HTTPS 和 HTTP 的区别">HTTPS 和 HTTP 的区别</h3>
<ol>
<li>https=http+TLS/SSL 协议，安装 SSL 证书后，使用 https 加密协议访问网站，可激活客户端浏览器到网站服务器之间的“SSL 加密通道”（SSL 协议），实现高强度双向加密传输，防止传输数据被泄露或篡改。</li>
<li>https 协议需要到 CA 申请证书，一般免费证书较少，因而需要一定费用。</li>
<li>http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443。</li>
</ol>
<p>TLS/SSL 协议位于应用层协议和 TCP 之间，构建在 TCP 之上，由 TCP 协议保证数据传输版的可靠性，任何数据到达 TCP 之前，都经过 TLS/SSL 协议处理。不光是 HTTP 协议，其他运行在应用层的 SMTP 和 Telnet 等协议均可配合 SSL 协议使用。可以说 SSL 是当今世界上应用最为广泛的网络安全技术。</p>
<img src="https://tva1.sinaimg.cn/large/008i3skNly1gz2szp8awaj31780ie401.jpg" alt="image-20220205181824932" style="zoom:33%;" />
<p>https 是加密传输协议，可以保障客户端到服务器端的传输数据安全。用户通过 http 协议访问网站时，浏览器和服务器之间是明文传输，这就意味着用户填写的密码、帐号、交易记录等机密信息都是明文，随时可能被泄露、窃取、篡改，被第三者加以利用。安装 SSL 证书后，使用 https 加密协议访问网站，可激活客户端浏览器到网站服务器之间的 &quot;SSL 加密通道 &quot;（SSL 协议），实现高强度双向加密传输，防止传输数据被泄露或篡改。</p>
<h3 id="对称加密和非对称加密的区别">对称加密和非对称加密的区别</h3>
<p>对称加密的客户端和服务端对于加密解密使用同一个密钥。而密钥在传送的过程中可能会被监听。所以另外还得设法安全地保管接收到的密钥。所以对称加密有一定的风险。</p>
<p>非对称加密就是使用公开密钥和私有密钥两把密钥进行加密解密。<strong>使用公开密钥加密方式，发送密文的一方使用对方的公开密钥进行加密处理，对方收到被加密的信息后，再使用自己的私有密钥进行解密。</strong> 缺点是处理速度比较慢。</p>
<p>现实中是两种加密方式结合使用。采用混合加密机制。</p>
<h3 id="https 的 ssl 连接过程">https 的 ssl 连接过程</h3>
<ol>
<li>客户端提交 https 请求</li>
<li>服务器响应客户，并把信息通过证书公钥加密后发给客户端（此时产生了公钥和私钥，只把公钥给客户端）</li>
<li>客户端验证证书公钥的有效性</li>
<li>有效后，会生成一个会话密钥</li>
<li>用证书公钥加密这个会话密钥后，发送给服务器</li>
<li>服务器收到公钥加密的会话密钥后，用私钥解密，得到会话密钥</li>
<li>客户端与服务器双方利用这个会话密钥加密要传输的数据进行通信</li>
</ol>
<img src="https://tva1.sinaimg.cn/large/008i3skNly1gz3pm0o5ydj31270u043b.jpg" alt="image-20220206130705481" style="zoom:50%;" />
<h3 id="客户端如何验证证书的合法性">客户端如何验证证书的合法性</h3>
<ol>
<li>首先浏览器读取证书中的证书所有者、有效期等信息进行校验，校验证书的网站域名是否与证书颁发的域名一致，校验证书是否在有效期内</li>
<li>浏览器开始查找操作系统中已内置的受信任的证书发布机构 CA，与服务器发来的证书中的颁发者 CA 比对，用于校验证书是否为合法机构颁发</li>
<li>如果找不到，浏览器就会报错，说明服务器发来的证书是不可信任的。</li>
<li>如果找到，那么浏览器就会从操作系统中取出颁发者 CA 的公钥(多数浏览器开发商发布版本时，会事先在内部植入常用认证机关的公开密钥)，然后对服务器发来的证书里面的签名进行解密</li>
<li>浏览器使用相同的 hash 算法计算出服务器发来的证书的 hash 值，将这个计算的 hash 值与证书中签名做对比</li>
<li>对比结果一致，则证明服务器发来的证书合法，没有被冒充</li>
</ol>
<h3 id="如何让 UDP 可靠传输">如何让 UDP 可靠传输</h3>
<p><strong>在应用层</strong></p>
<ol>
<li>添加 seq/ack 机制，确保数据发送到对端</li>
<li>添加发送和接收缓冲区，主要是用户超时重传</li>
<li>添加超时重传机制</li>
</ol>
<p><strong>详细说明：</strong> 发送端发送数据时，生成一个随机 seq=x，然后每一片按照数据大小分配 seq。数据到达接收端后接收端放入缓存，并发送一个 ack=x 的包，表示对方已经收到了数据。发送端收到了 ack 包后，删除缓冲区对应的数据。时间到后，定时任务检查是否需要重传数据</p>
<h3 id="HTTP 的状态码有哪些">HTTP 的状态码有哪些</h3>
<p>服务器返回的 <strong> 响应报文 </strong> 中第一行为状态行，包含了状态码以及原因短语，用来告知客户端请求的结果。</p>
<table>
<thead>
<tr>
<th style="text-align:center">状态码</th>
<th style="text-align:center">类别</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1XX</td>
<td style="text-align:center">Informational (信息性状态码)</td>
<td style="text-align:center">接收的请求正在处理</td>
</tr>
<tr>
<td style="text-align:center">2XX</td>
<td style="text-align:center">Success (成功状态码)</td>
<td style="text-align:center">请求正常处理完毕</td>
</tr>
<tr>
<td style="text-align:center">3XX</td>
<td style="text-align:center">Redirection (重定向状态码)</td>
<td style="text-align:center">需要进行附加操作以完成请求</td>
</tr>
<tr>
<td style="text-align:center">4XX</td>
<td style="text-align:center">Client Error (客户端错误状态码)</td>
<td style="text-align:center">服务器无法处理请求</td>
</tr>
<tr>
<td style="text-align:center">5XX</td>
<td style="text-align:center">Server Error (服务器错误状态码)</td>
<td style="text-align:center">服务器处理请求出错</td>
</tr>
</tbody>
</table>
<ol>
<li><strong>1XX 信息</strong></li>
</ol>
<ul>
<li><strong>100 Continue</strong> ：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。</li>
</ul>
<ol start="2">
<li><strong>2XX 成功</strong></li>
</ol>
<ul>
<li><strong>200 OK</strong></li>
<li><strong>204 No Content</strong> ：请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用。</li>
<li><strong>206 Partial Content</strong> ：表示客户端进行了范围请求，响应报文包含由 Content-Range 指定范围的实体内容。</li>
</ul>
<ol start="3">
<li><strong>3XX 重定向</strong></li>
</ol>
<ul>
<li><strong>301 Moved Permanently</strong> ：永久性重定向</li>
<li><strong>302 Found</strong> ：临时性重定向</li>
<li><strong>303 See Other</strong> ：和 302 有着相同的功能，但是 303 明确要求客户端应该采用 GET 方法获取资源。</li>
<li>注：虽然 HTTP 协议规定 301、302 状态下重定向时不允许把 POST 方法改成 GET 方法，但是大多数浏览器都会在 301、302 和 303 状态下的重定向把 POST 方法改成 GET 方法。</li>
<li><strong>304 Not Modified</strong> ：如果请求报文首部包含一些条件，例如：If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since，如果不满足条件，则服务器会返回 304 状态码。</li>
<li><strong>307 Temporary Redirect</strong> ：临时重定向，与 302 的含义类似，但是 307 要求浏览器不会把重定向请求的 POST 方法改成 GET 方法。</li>
</ul>
<ol start="4">
<li><strong>4XX 客户端错误</strong></li>
</ol>
<ul>
<li><strong>400 Bad Request</strong> ：请求报文中存在语法错误。</li>
<li><strong>401 Unauthorized</strong> ：该状态码表示发送的请求需要有认证信息（BASIC 认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败。</li>
<li><strong>403 Forbidden</strong> ：请求被拒绝。</li>
<li><strong>404 Not Found</strong></li>
</ul>
<ol start="5">
<li><strong>5XX 服务器错误</strong></li>
</ol>
<ul>
<li><strong>500 Internal Server Error</strong> ：服务器正在执行请求时发生错误。</li>
<li><strong>503 Service Unavailable</strong> ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。</li>
</ul>
<h3 id="TCP 和 UDP 的区别">TCP 和 UDP 的区别</h3>
<p><strong>TCP 协议的主要特点</strong></p>
<ol>
<li>TCP 是面向连接的运输层协议；所谓面向连接就是双方传输数据之前，必须先建立一条通道，例如三次握手就是建议通道的一个过程，而四次挥手则是结束销毁通道的一个其中过程。</li>
<li>每一条 TCP 连接只能有两个端点（即两个套接字），只能是点对点的</li>
<li>TCP 提供可靠的传输服务。传送的数据无差错、不丢失、不重复、按序到达</li>
<li>TCP 提供全双工通信。允许通信双方的应用进程在任何时候都可以发送数据，因为两端都设有发送缓存和接收缓存</li>
<li>面向字节流。虽然应用程序与 TCP 交互是一次一个大小不等的数据块，但 TCP 把这些数据看成一连串无结构的字节流，它不保证接收方收到的数据块和发送方发送的数据块具有对应大小关系，例如，发送方应用程序交给发送方的 TCP10 个数据块，但就受访的 TCP 可能只用了 4 个数据块就把收到的字节流交付给上层的应用程序，但字节流完全一样。</li>
</ol>
<p><strong>TCP 的可靠性原理</strong></p>
<p>可靠传输有如下两个特点：</p>
<ul>
<li>传输信道无差错，保证传输数据正确</li>
<li>不管发送方以多快的速度发送数据，接收方总是来得及处理收到的数据</li>
</ul>
<ol>
<li>首先，采用三次握手来建立 TCP 连接，四次握手来释放 TCP 连接，从而保证建立的传输信道是可靠的</li>
<li>其次，TCP 采用了连续 ARQ 协议（回退 N，Go-back-N；超时自动重传）来保证数据传输的正确性，使用滑动窗口协议来保证接方能够及时处理所接收到的数据，进行流量控制</li>
<li>最后，TCP 使用慢开始、拥塞避免、快重传和快恢复来进行拥塞控制，避免网络拥塞</li>
</ol>
<p><strong>UDP 协议特点</strong></p>
<ol>
<li>UDP 是无连接的传输层协议</li>
<li>UDP 使用尽最大努力交付，不保证可靠交付</li>
<li>UDP 是面向报文的，对应用层交下来的报文，不合并，不拆分，保留原报文的边界</li>
<li>UDP 没有拥塞控制，因此即使网络出现拥塞也不会降低发送速率</li>
<li>UDP 支持一对一、一对多、多对多的交互通信</li>
<li>UDP 的首部开销小，只有８字节</li>
</ol>
<p><strong>区别</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">TCP</th>
<th style="text-align:center">UDP</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">可靠传输</td>
<td style="text-align:center">不可靠传输</td>
</tr>
<tr>
<td style="text-align:center">面向连接</td>
<td style="text-align:center">无连接</td>
</tr>
<tr>
<td style="text-align:center">传输数据有序</td>
<td style="text-align:center">不保证数据的有序性</td>
</tr>
<tr>
<td style="text-align:center">不保存数据边界</td>
<td style="text-align:center">保留数据边界</td>
</tr>
<tr>
<td style="text-align:center">传输速度较慢</td>
<td style="text-align:center">传输速度较快</td>
</tr>
<tr>
<td style="text-align:center">有流量控制和拥塞控制</td>
<td style="text-align:center">无流量控制和拥塞控制</td>
</tr>
<tr>
<td style="text-align:center">重量级协议</td>
<td style="text-align:center">轻量级协议</td>
</tr>
<tr>
<td style="text-align:center">首部较长，20 字节</td>
<td style="text-align:center">首部较短，8 字节</td>
</tr>
</tbody>
</table>
<p><strong>基于 TCP 和 UDP 的常用协议</strong></p>
<ol>
<li>
<p><strong>TCP 对应的应用层协议</strong></p>
<p><strong>FTP：</strong> 定义了文件传输协议，使用 21 端口。常说某某计算机开了 FTP 服务便是启动了文件传输服务。下载文件，上传主页，都要用到 FTP 服务。</p>
<p><strong>Telnet：</strong> 它是一种用于远程登陆的端口，用户可以以自己的身份远程连接到计算机上，通过这种端口可以提供一种基于 DOS 模式下的通信服务。如以前的 BBS 是纯字符界面的，支持 BBS 的服务器将 23 端口打开，对外提供服务。</p>
<p><strong>SMTP：</strong> 定义了简单邮件传送协议，现在很多邮件服务器都用的是这个协议，用于发送邮件。如常见的免费邮件服务中用的就是这个邮件服务端口，所以在电子邮件设置中常看到有这么 SMTP 端口设置这个栏，服务器开放的是 25 号端口。</p>
<p><strong>POP3：</strong> 它是和 SMTP 对应，POP3 用于接收邮件。通常情况下，POP3 协议所用的是 110 端口。也是说，只要你有相应的使用 POP3 协议的程序（例如 Foxmail 或 Outlook），就可以不以 Web 方式登陆进邮箱界面，直接用邮件程序就可以收到邮件（如是 163 邮箱就没有必要先进入网易网站，再进入自己的邮箱来收信）。</p>
<p><strong>HTTP：</strong> 从 Web 服务器传输超文本到本地浏览器的传送协议。</p>
</li>
<li>
<p><strong>UDP 对应的应用层协议</strong></p>
<p><strong>DNS：</strong> 用于域名解析服务，将域名地址转换为 IP 地址。DNS 用的是 53 号端口。</p>
<p><strong>SNMP：</strong> 简单网络管理协议，使用 161 号端口，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势。</p>
<p><strong>TFTP(Trival File Transfer Protocal)：</strong> 简单文件传输协议，该协议在熟知端口 69 上使用 UDP 服务。</p>
</li>
</ol>
<h3 id="什么是 MAC 地址">什么是 MAC 地址</h3>
<p>每个网卡上有 MAC 地址</p>
<p>格式：12 个十六进制数字，两两一组，即 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>48</mn></msup></mrow><annotation encoding="application/x-tex">2^{48}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">48</span></span></span></span></span></span></span></span></span></span></span></span> 个数</p>
<p>比如一段 MAC 地址：AA-BB-CC-DD-EE-FF</p>
<p>前三组是厂商识别码，由 IEEE 分配。后 3 组厂商自己决定。</p>
<h3 id="MAC 地址冲突怎么办？">MAC 地址冲突怎么办？</h3>
<p>一般几乎不会冲突，MAC 在本局域网内和本地 IP 映射，只要在自己网段内没有相同的就行。一旦跨网段，那么即使有两个相同的 MAC 地址也无所谓。</p>
<h3 id="MAC 地址能否更改">MAC 地址能否更改</h3>
<p>MAC 地址是固化在硬件设备里的，一般情况下是不能更改的，但了解到也有相关的技术能够修改 MAC 地址</p>
<h3 id="怎么判断一个网络传输中一个包失效了？">怎么判断一个网络传输中一个包失效了？</h3>
<p>查看一个包的 TTL，TTL 减到 0 的时候它就会自动失效被丢弃。TTL 每经过一个路由器就会减一。</p>
<h3 id="如果一个包报错无用了，网络中会发生什么？">如果一个包报错无用了，网络中会发生什么？</h3>
<p>ICMP 会向整个网络发送通知告诉这个包已经失效。可以根据 Ping(ICMP 协议)得到 TTL 进行分析</p>
<h3 id="IPv4 和 IPv6 的区别？">IPv4 和 IPv6 的区别？</h3>
<ol>
<li>
<p><strong>在表现形式上</strong></p>
<ul>
<li>IPv4 是 32 位，共有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>32</mn></msup></mrow><annotation encoding="application/x-tex">2^{32}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">32</span></span></span></span></span></span></span></span></span></span></span></span> 个数字，IPv6 则有 128 位，共有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>128</mn></msup></mrow><annotation encoding="application/x-tex">2^{128}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">128</span></span></span></span></span></span></span></span></span></span></span></span> 个数字</li>
<li>IPv4 基本表示时每个位都是十进制，IPv6 每个位都是十六进制</li>
<li>IPv4 的网络标识和主机标识分为 ABCD 类，或者根据子网掩码设置任意长度，而 IPv6 的前 64 位是网络标识，后 64 位是主机标识</li>
</ul>
</li>
<li>
<p><strong>性能提升</strong></p>
<p>IPv6 包首部长度采用固定的值（40 字节），不再采用首部检验码，没有了首部校验和字段。<strong>简化首部结构，减轻路由器负荷。</strong> 路由器不再做分片处理。</p>
</li>
<li>
<p><strong>支持即插即用功能</strong></p>
<p>IPv6 即使没有 DHCP 服务器也可以实现自动分配 IP 地址。而 IPv4 协议的地址需要通过手动或 DHCP 配置的。</p>
</li>
<li>
<p><strong>采用认证与加密功能，更加安全</strong></p>
<p>IPv6 有应对伪造 IP 地址的网络安全功能以及防止线路窃听的功能（IPsec）。</p>
</li>
<li>
<p><strong>IP 地址的扩大与路由控制表的聚合</strong></p>
<p>IPv6 的 IP 地址依然适应互联网分层构造。分配与其地址结构相适应的 IP 地址，尽可能避免路由表膨大。路由器的路由表长度减少，提高转发数据包的速度。</p>
</li>
<li>
<p><strong>多播、Mobile IP 成为扩展功能</strong></p>
<p>多播和 Mobile IP 被定义为 IPv6 的扩展功能。由此可以预期，曾在 IPv4 中难于应用的这两个功能在 IPv6 中能够顺利使用。</p>
<ul>
<li>
<p><strong>多播</strong></p>
<p>允许主机发送单一数据包到多台主机的网络技术。多播是一对多的通信，而不是采用重复的点对点的通信或广播方式，后两者均严重浪费网络带宽。</p>
</li>
<li>
<p><strong>Mobile IP</strong></p>
<p>允许移动节点（不限于手机）在不改变 IP 地址的情况下可以从一个子网移动到其他子网</p>
</li>
</ul>
</li>
<li>
<p><strong>在 IPv6 协议，地址解析协议（ARP）被邻居发现协议（NDP）的功能所取代。</strong></p>
</li>
</ol>
<h3 id="Cookies">Cookies</h3>
<ul>
<li>
<p><strong>含义</strong></p>
<p>Cookie 实际上由 Web 服务器置于你硬盘上的一个非常小的文本文件。客户端请求服务器，如果服务器需要记录该用户状态，就使用 response 向客户端浏览器颁发一个 Cookie。客户端浏览器会把 Cookie 保存起来，它可以记录你的用户 ID、密码、浏览过的网页、停留的时间等信息。<strong>当浏览器再请求该网站时，浏览器把请求的网址连同该 Cookie 一同提交给服务器。</strong> 服务器检查该 Cookie 里之前保存的信息状态，如果正确，就会直接跳过用户名密码，直接返回欢迎界面。服务器还可以根据需要修改 Cookie 的内容。</p>
<p>Cookies 中的内容大多数 <strong> 经过了加密处理</strong>，因此一般用户看来只是一些毫无意义的字母数字组合，只有服务器的 CGI 处理程序才知道它们真正的含义。</p>
</li>
<li>
<p><strong>作用</strong></p>
<p>因为 http 协议是不能保存状态的，下一次连接不知道上一次连接的信息，这样虽然简单但造成很多问题，比如登录界面购物之后，再跳转到其他界面，仍然需要保存之前的登录信息，因此出现了 cookie 技术，用来保存 http 的连接的状态信息。</p>
</li>
<li>
<p><strong>应用</strong></p>
<ul>
<li>会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</li>
<li>个性化设置（如用户自定义设置、主题等）</li>
<li>浏览器行为跟踪（如跟踪分析用户行为等）</li>
</ul>
</li>
<li>
<p><strong>创建过程</strong></p>
<p>服务器发送的响应报文包含 Set-Cookie 首部字段，客户端得到响应报文后把 Cookie 内容保存到浏览器中。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.0 200 OK</span><br><span class="line">Content-type: text/html</span><br><span class="line">Set-Cookie: yummy_cookie=choco</span><br><span class="line">Set-Cookie: tasty_cookie=strawberry</span><br><span class="line"></span><br><span class="line">[page content]</span><br></pre></td></tr></table></figure>
<p>客户端之后对同一个服务器发送请求时，会从浏览器中取出 Cookie 信息并通过 Cookie 请求首部字段发送给服务器。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET /sample_page.html HTTP/1.1</span><br><span class="line">Host: www.example.org</span><br><span class="line">Cookie: yummy_cookie=choco; tasty_cookie=strawberry</span><br></pre></td></tr></table></figure>
<img src="https://tva1.sinaimg.cn/large/008i3skNly1gz40pgyxc2j31290u0jwb.jpg" alt="image-20220206193056183" style="zoom:33%;" />
</li>
<li>
<p><strong>分类</strong></p>
<ul>
<li>会话期 Cookie：浏览器关闭之后它会被自动删除，也就是说它仅在会话期内有效。</li>
<li>持久性 Cookie：指定过期时间（Expires）或有效期（max-age）之后就成为了持久性的 Cookie。</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="Session">Session</h3>
<p>除了可以将用户信息通过 Cookie 存储在用户浏览器中，也可以利用 Session 存储在服务器端，存储在服务器端的信息更加安全，它使用 <strong> 类似于哈希表的结构来保存信息</strong>。</p>
<p>Session 可以存储在服务器上的文件、数据库或者内存中。也可以将 Session 存储在 Redis 这种内存型数据库中，效率会更高。</p>
<p>使用 Session 维护用户登录状态的过程如下：</p>
<ul>
<li>用户进行登录时，用户提交包含用户名和密码的表单，放入 HTTP 请求报文中；</li>
<li>服务器验证该用户名和密码，如果正确则把用户信息存储到 Redis 中，它在 Redis 中的 Key 称为 Session ID；</li>
<li>服务器返回的响应报文的 Set-Cookie 首部字段包含了这个 Session ID，客户端收到响应报文之后将该 Cookie 值存入浏览器中；</li>
<li>客户端之后对同一个服务器进行请求时会包含该 Cookie 值，服务器收到之后提取出 Session ID，从 Redis 中取出用户信息，继续之前的业务操作。</li>
</ul>
<p>应该注意 Session ID 的安全性问题，不能让它被恶意攻击者轻易获取，那么就不能产生一个容易被猜到的 Session ID 值。此外，还需要经常重新生成 Session ID。在对安全性要求极高的场景下，例如转账等操作，除了使用 Session 管理用户状态之外，还需要对用户进行重新验证，比如重新输入密码，或者使用短信验证码等方式。</p>
<h3 id="Cookie 和 Session 的区别">Cookie 和 Session 的区别</h3>
<table>
<thead>
<tr>
<th style="text-align:center">Cookie</th>
<th style="text-align:center">Session</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">保存在浏览器</td>
<td style="text-align:center">保存在服务器</td>
</tr>
<tr>
<td style="text-align:center">不安全</td>
<td style="text-align:center">安全</td>
</tr>
<tr>
<td style="text-align:center">不占用服务器，性能高</td>
<td style="text-align:center">占用服务器，性能低</td>
</tr>
<tr>
<td style="text-align:center">存储空间小</td>
<td style="text-align:center">存储空间大</td>
</tr>
<tr>
<td style="text-align:center">本地计算机上的小块文件</td>
<td style="text-align:center">哈希表结构存储信息</td>
</tr>
</tbody>
</table>
<h3 id="禁用 Cookie 如何使用 Session-ID">禁用 Cookie 如何使用 Session ID?</h3>
<p>如果客户端的浏览器禁用了 Cookie，会使用一种叫做<strong>URL 重写的技术来进行会话跟踪</strong>，即每次 HTTP 交互，URL 后面都会被附加上一个诸如 sid=xxxxx 这样的参数，服务端据此来识别用户，这样就可以帮用户完成诸如用户名等信息自动填入的操作了。</p>
<h3 id="http 请求报文中，host 字段是必须存在的吗？">http 请求报文中，host 字段是必须存在的吗？</h3>
<p>是，host 是在 HTTP/1.1 规范内是唯一一个必须包含在请求内的首部字段。</p>
<p>虽然客户端请求中有服务器主机名，服务器会把该主机名替换为 IP 地址，但是有些服务器中利用虚拟机，在相同的 IP 地址服务器下部署运行着多个域名，没有 host 服务器可能就没办法知道客户端请求的是哪个域名。</p>
<h3 id="http 方法">http 方法</h3>
<p>客户端发送的 <strong>请求报文</strong> 第一行为请求行，包含了方法字段。</p>
<ol>
<li>
<p><strong>GET</strong></p>
<blockquote>
<p>获取资源</p>
</blockquote>
<p>当前网络请求中，绝大部分使用的是 GET 方法。</p>
</li>
<li>
<p><strong>HEAD</strong></p>
<blockquote>
<p>获取报文首部</p>
</blockquote>
<p>和 GET 方法类似，但是不返回报文实体主体部分。</p>
<p>主要用于确认 URL 的有效性以及资源更新的日期时间等。</p>
</li>
<li>
<p><strong>POST</strong></p>
<blockquote>
<p>传输实体主体</p>
</blockquote>
<p>POST 主要用来传输数据，而 GET 主要用来获取资源。</p>
</li>
<li>
<p><strong>PUT</strong></p>
<blockquote>
<p>上传文件</p>
</blockquote>
<p>由于自身不带验证机制，任何人都可以上传文件，因此存在安全性问题，一般不使用该方法。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PUT /new.html HTTP/1.1</span><br><span class="line">Host: example.com</span><br><span class="line">Content-type: text/html</span><br><span class="line">Content-length: 16</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>New File<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>PATCH</strong></p>
<blockquote>
<p>对资源进行部分修改</p>
</blockquote>
<p>PUT 也可以用于修改资源，但是只能完全替代原始资源，PATCH 允许部分修改。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PATCH /file.txt HTTP/1.1</span><br><span class="line">Host: www.example.com</span><br><span class="line">Content-Type: application/example</span><br><span class="line">If-Match: &quot;e0023aa4e&quot;</span><br><span class="line">Content-Length: 100</span><br><span class="line"></span><br><span class="line">[description of changes]</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>DELETE</strong></p>
<blockquote>
<p>删除文件</p>
</blockquote>
<p>与 PUT 功能相反，并且同样不带验证机制。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE /file.html HTTP/1.1</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>OPTIONS</strong></p>
<blockquote>
<p>查询支持的方法</p>
</blockquote>
<p>查询指定的 URL 能够支持的方法。</p>
<p>会返回 <code>Allow: GET, POST, HEAD, OPTIONS</code> 这样的内容。</p>
</li>
<li>
<p><strong>CONNECT</strong></p>
<blockquote>
<p>要求在与代理服务器通信时建立隧道</p>
</blockquote>
<p>使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONNECT www.example.com:443 HTTP/1.1</span><br></pre></td></tr></table></figure>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gz413yz5fjj30ze09gaau.jpg" alt="image-20220206194457389"></p>
</li>
<li>
<p><strong>TRACE</strong></p>
<blockquote>
<p>追踪路径</p>
</blockquote>
<p>服务器会将通信路径返回给客户端。</p>
<p>发送请求时，在 Max-Forwards 首部字段中填入数值，每经过一个服务器就会减 1，当数值为 0 时就停止传输。</p>
<p>通常不会使用 TRACE，并且它容易受到 XST 攻击（Cross-Site Tracing，跨站追踪）。</p>
</li>
</ol>
<h3 id="GET 和 POST 请求的区别">GET 和 POST 请求的区别</h3>
<table>
<thead>
<tr>
<th style="text-align:center">请求方式</th>
<th style="text-align:center">GET</th>
<th style="text-align:center">POST</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">参数位置</td>
<td style="text-align:center">URL 的 query 中</td>
<td style="text-align:center">一般在 content 中，query 也可以</td>
</tr>
<tr>
<td style="text-align:center">参数大小</td>
<td style="text-align:center">受限于浏览器 URL 大小，一般不超过 32K</td>
<td style="text-align:center">1G</td>
</tr>
<tr>
<td style="text-align:center">服务器数据接受</td>
<td style="text-align:center">接收 1 次</td>
<td style="text-align:center">根据数据大小，可分多次接收</td>
</tr>
<tr>
<td style="text-align:center">适用场景（语义）</td>
<td style="text-align:center">从服务器端获取数据，不做增删改</td>
<td style="text-align:center">向服务器提交数据，如做增删改操作</td>
</tr>
<tr>
<td style="text-align:center">安全性</td>
<td style="text-align:center">参数携带在 URL 中，安全性低</td>
<td style="text-align:center">相对于 GET 请求，安全性更高</td>
</tr>
</tbody>
</table>
<p><strong>另外：</strong> GET 请求会被浏览器主动缓存，而 POST 不会，除非手动设置。</p>
<p><strong>本质区别：GET 是幂等的，而 POST 不是幂等的。</strong></p>
<p><strong>幂等性：指一次和多次请求某一个资源应该具有同样的副作用</strong>。简单来说意味着对同一 URL 的多个请求应该返回同样的结果。</p>
<p>正因为它们有这样的区别，所以不应该且不能用 get 请求做数据的增删改这些有副作用的操作。因为 get 请求是幂等的，在网络不好的隧道中会尝试重试。如果用 get 请求增数据，会有重复操作的风险，而这种重复操作可能会导致副作用（浏览器和操作系统并不知道你会用 get 请求去做增操作）。</p>
<p><strong>安全性</strong></p>
<p>安全的 HTTP 方法不会改变服务器状态，也就是说它只是可读的。</p>
<p>GET 方法是安全的，而 POST 却不是，因为 POST 的目的是传送实体主体内容，这个内容可能是用户上传的表单数据，上传成功之后，服务器可能把这个数据存储到数据库中，因此状态也就发生了改变。</p>
<p>安全的方法除了 GET 之外还有：HEAD、OPTIONS。</p>
<p>不安全的方法除了 POST 之外还有 PUT、DELETE。</p>
<h3 id="网络各层校验用的是什么？">网络各层校验用的是什么？</h3>
<p><strong>运输层：</strong> TCP 协议中规定，TCP 的首部字段中有一个字段是校验和，发送方 <strong> 将伪首部、TCP 首部、TCP 数据使用累加和校验的方式计算出一个数字，然后存放在首部的校验和字段里，</strong> 接收者收到 TCP 包后重复这个过程，然后将计算出的校验和和接收到的首部中的校验和比较，如果不一致则说明数据在传输过程中出错。<strong>这就是 TCP 的数据校验机制</strong>。</p>
<p><strong>网络层(IP 层)：</strong> 也是首部校验和</p>
<p><strong>数据链路层：</strong> 奇偶校验码（Parity Check Code, PCC）、循环冗余校验（Cyclic Redundancy Check, CRC）两种</p>
<h3 id="TCP 如何保证数据的正确性？">TCP 如何保证数据的正确性？</h3>
<p>使用 <strong> 首部校验 </strong> 的方法保证数据的正确性。但这个校验机制不能够确保数据传输不会出错。</p>
<p>因为这种校验方式是累加和，也就是将一系列的数字（TCP 协议规定的是数据中的每 16 个比特位数据作为一个数字）求和后取末位。但是小学生都知道 A+B=B+A，假如在传输的过程中有前后两个 16 比特位的数据前后颠倒了，那么校验和的计算结果和颠倒之前是一样的，那么接收端肯定无法检查出这是错误的数据。</p>
<p>可以在应用层自己建立一套新的数据校验机制。最简单的就是使用 MD5 校验，在发送数据前将数据使用 MD5 加密，并将 MD5 摘要一起发送，接收端接收数据后将数据再次用 MD5 加密，如果得到的摘要和收到的摘要一致说明数据正确。</p>
<h3 id="HTTP-1-0-1-1-2-0 的区别">HTTP 1.0 / 1.1 / 2.0 的区别</h3>
<p>HTTP1.0 每次发送链接都要重新建立新的 tcp 链接，非常低效，HTTP1.1 开发了长连接功能，这样就不用每次都进行 tcp 链接，不过因为需要添加 keep alive 头部，所以网络传输数据量会略微增大，HTTP2.0 传输速度非常快，首先它对头部进行了压缩，所以网络传输数据量会小很多，HTTP2.0 的核心在于，HTTP1.1 请求图片 1 和图片 2，必须按照顺序先返回图片 1，再返回图片 2。但是有时候图片大小是不一样的，这就导致即使开再多的 tcp 链接，如果图片 1 显示不出来，图片 2 也显示不出来。而 HTTP2.0 可以一次性请求多个图片，服务器返回的话可以不按照顺序。而且如下图 HTTP2.0 的 TCP 链接数量只需要一个。</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gz41pjnxklj324q0u0n1q.jpg" alt="image-20220206200541383"></p>
<ol>
<li>
<p><strong>HTTP1.0 和 HTTP1.1 的区别？</strong></p>
<ul>
<li><strong>带宽优化及网络连接的使用 </strong>，HTTP1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1 则在请求头引入了 range 头域，<strong> 它允许只请求资源的某个部分，即返回码是 206</strong>（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</li>
<li><strong>更多的缓存处理策略</strong>，在 HTTP1.0 中主要使用 header 里的 If-Modified-Since, Expires 来做为缓存判断的标准，HTTP1.1 则引入了更多的缓存控制策略例如 Entity tag，If-Unmodified-Since, If-Match, If-None-Match 等更多可供选择的缓存头来控制缓存策略。</li>
<li><strong>在 HTTP1.1 中新增了 24 个错误状态响应码。</strong></li>
<li>http1.0 中默认每台服务器都绑定唯一的一个 IP 地址，所以一般请求消息中 <strong>url 并没有传递主机名。</strong> 而因为一台服务器可能有多个虚拟机多个域名共享一个 IP 地址，所以 http1.1 中请求消息和响应消息都支持 Host 头域，而且如果我们不传这个字段还会报一个 400(bad request) 的状态码</li>
<li><strong>长连接。</strong> HTTP 1.1 支持长连接和请求的流水线处理，<strong>在一个 TCP 连接上可以传送多个 HTTP 请求和响应，减少了建立和关闭连接的消耗和延迟</strong>，在 HTTP1.1 中默认开启 Connection： <strong>keep-alive</strong>，一定程度上弥补了 HTTP1.0 每次请求都要创建连接的缺点。</li>
</ul>
</li>
<li>
<p><strong>HTTP2.0 和 HTTP1.X 相比的新特性？</strong></p>
<ul>
<li><strong>新的二进制格式</strong>（Binary Format），<strong>HTTP1.x 的解析是基于文本</strong>。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认 0 和 1 的组合。基于这种考虑<strong>HTTP2.0 的协议解析决定采用二进制格式</strong>，实现方便且健壮。</li>
<li><strong>多路复用 </strong>（MultiPlexing），也就是说<strong> 多个请求共享一个 tcp 连接的方式 </strong>。即连接共享，即每一个 request 都是用作连接共享机制的。一个 request 对应一个 id，这样一个连接上可以有多个 request，每个连接的 request 可以随机的混杂在一起，<strong> 接收方可以根据 request 的 id 将 request 再归属到各自不同的服务端请求里面。</strong></li>
<li><strong>header 压缩</strong>，如上文中所言，对前面提到过 HTTP1.x 的 header 带有大量信息，而且每次都要重复发送，HTTP2.0 使用 encoder 来减少需要传输的 header 大小，通讯双方各自 cache 一份 header fields 表，既避免了重复 header 的传输，又减小了需要传输的大小。</li>
<li><strong>服务端推送（server push）</strong>，例如我的网页有一个 sytle.css 的请求，在客户端收到 sytle.css 数据的同时，服务端会将 sytle.js 的文件推送给客户端，当客户端再次尝试获取 sytle.js 时就可以直接从缓存中获取到，不用再发请求了。</li>
</ul>
<img src="https://tva1.sinaimg.cn/large/008i3skNly1gz42ag30yuj30un0u0mzd.jpg" alt="image-20220206202546272" style="zoom:33%;" />
</li>
</ol>
<h3 id="最大 TCP 连接数是多少？">最大 TCP 连接数是多少？</h3>
<p>理论上是等于 <code> 客户端 IP 数×客户端的端口数</code>，即 2^32^ × 2^16^ 即 2^48^ ，但是实际上受到文件描述符数量限制和内存空间限制。</p>
<h3 id="什么是 SQL 注入？">什么是 SQL 注入？</h3>
<p>SQL 注入就是通过把 SQL 命令插入到 Web 表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的 SQL 命令。</p>
<h3 id="每一层对应的网络协议有哪些？">每一层对应的网络协议有哪些？</h3>
<img src="https://tva1.sinaimg.cn/large/008i3skNly1gz42f4xs4kj30re16a42s.jpg" alt="image-20220206203016645" style="zoom:33%;" />
<h3 id="为什么 TIME-WAIT- 状态必须等待 -2MSL- 的时间？">为什么 TIME-WAIT 状态必须等待 2MSL 的时间？</h3>
<ol>
<li>为了保证 A 发送的最后一个 ACK 报文段能够到达 B。这个 ACK 报文段有可能丢失，因而使处在 LAST-ACK 状态的 B 收不到对已发送的 FIN + ACK 报文段的确认。B 会超时重传这个 FIN+ACK 报文段，而 A 就能在 2MSL 时间内（超时 + 1MSL 传输）收到这个重传的 FIN+ACK 报文段。接着 A 重传一次确认，重新启动 2MSL 计时器。最后，A 和 B 都正常进入到 CLOSED 状态。如果 A 在 TIME-WAIT 状态不等待一段时间，而是在发送完 ACK 报文段后立即释放连接，那么就无法收到 B 重传的 FIN + ACK 报文段，因而也不会再发送一次确认报文段，这样，B 就无法按照正常步骤进入 CLOSED 状态。</li>
<li>防止已失效的连接请求报文段出现在本连接中。A 在发送完最后一个 ACK 报文段后，再经过时间 2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样就可以使下一个连接中不会出现这种旧的连接请求报文段。</li>
</ol>
<h3 id="DNS 的解析过程">DNS 的解析过程</h3>
<ol>
<li><strong>主机向本地域名服务器的查询一般都是采用递归查询。</strong> 所谓递归查询就是：如果主机所询问的本地域名服务器不知道被查询的域名的 IP 地址，那么本地域名服务器就以 DNS 客户的身份，向根域名服务器继续发出查询请求报文(即替主机继续查询)，而不是让主机自己进行下一步查询。因此，递归查询返回的查询结果或者是所要查询的 IP 地址，或者是报错，表示无法查询到所需的 IP 地址。</li>
<li><strong>本地域名服务器向根域名服务器的查询的迭代查询。</strong> 迭代查询的特点：当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出所要查询的 IP 地址，要么告诉本地服务器：“你下一步应当向哪一个域名服务器进行查询”。然后让本地服务器进行后续的查询。根域名服务器通常是把自己知道的顶级域名服务器的 IP 地址告诉本地域名服务器，让本地域名服务器再向顶级域名服务器查询。顶级域名服务器在收到本地域名服务器的查询请求后，要么给出所要查询的 IP 地址，要么告诉本地服务器下一步应当向哪一个权限域名服务器进行查询。最后，本地域名服务器得到了所要解析的 IP 地址或报错，然后把这个结果返回给发起查询的主机。</li>
</ol>
<h3 id="域名缓存">域名缓存</h3>
<p>为了提高 DNS 查询效率，并减轻服务器的负荷和减少因特网上的 DNS 查询报文数量，在域名服务器中广泛使用了高速缓存，用来存放最近查询过的域名以及从何处获得域名映射信息的记录。</p>
<p>由于名字到地址的绑定并不经常改变，为保持高速缓存中的内容正确，域名服务器应为每项内容设置计时器并处理超过合理时间的项（例如：每个项目两天）。当域名服务器已从缓存中删去某项信息后又被请求查询该项信息，就必须重新到授权管理该项的域名服务器绑定信息。当权限服务器回答一个查询请求时，在响应中都指明绑定有效存在的时间值。增加此时间值可减少网络开销，而减少此时间值可提高域名解析的正确性。</p>
<p>不仅在本地域名服务器中需要高速缓存，在主机中也需要。许多主机在启动时从本地服务器下载名字和地址的全部数据库，维护存放自己最近使用的域名的高速缓存，并且只在从缓存中找不到名字时才使用域名服务器。维护本地域名服务器数据库的主机应当定期地检查域名服务器以获取新的映射信息，而且主机必须从缓存中删除无效的项。由于域名改动并不频繁，大多数网点不需花精力就能维护数据库的一致性。</p>
<h3 id="计算机网络体系结构">计算机网络体系结构</h3>
<img src="https://tva1.sinaimg.cn/large/008i3skNly1gz4305gnqkj311c0sutb4.jpg" alt="image-20220206205029450" style="zoom:33%;" />
<ol>
<li>
<p><strong>五层协议</strong></p>
<ul>
<li><strong>应用层 ：</strong> 为特定应用程序提供数据传输服务，例如 HTTP、DNS 等协议。数据单位为报文。</li>
<li><strong>传输层 ：</strong> 为进程提供通用数据传输服务。由于应用层协议很多，定义通用的传输层协议就可以支持不断增多的应用层协议。运输层包括两种协议：传输控制协议 TCP，提供面向连接、可靠的数据传输服务，数据单位为报文段；用户数据报协议 UDP，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。TCP 主要提供完整性服务，UDP 主要提供及时性服务。</li>
<li><strong>网络层 ：</strong> 为主机提供数据传输服务。而传输层协议是为主机中的进程提供数据传输服务。网络层把传输层传递下来的报文段或者用户数据报封装成分组。</li>
<li><strong>数据链路层 ：</strong> 网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧。</li>
<li><strong>物理层 ：</strong> 考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。</li>
</ul>
</li>
<li>
<p><strong>OSI 七层结构</strong></p>
<p>记忆：<strong>物联网叔会使用</strong></p>
<p>其中表示层和会话层用途如下：</p>
<ul>
<li><strong>表示层 ：</strong> 数据压缩、加密以及数据描述，这使得应用程序不必关心在各台主机中数据内部格式不同的问题。</li>
<li><strong>会话层 ：</strong> 建立及管理会话。</li>
</ul>
<p>五层协议没有表示层和会话层，而是将这些功能留给应用程序开发者处理。</p>
</li>
<li>
<p><strong>TCP/IP 结构</strong></p>
<p>它只有四层，相当于五层协议中数据链路层和物理层合并为网络接口层。</p>
<p>TCP/IP 体系结构不严格遵循 OSI 分层概念，应用层可能会直接使用 IP 层或者网络接口层。</p>
<img src="https://tva1.sinaimg.cn/large/008i3skNly1gz435pbv3ej30la0gyaaf.jpg" alt="image-20220206205549284" style="zoom:33%;" />
</li>
</ol>
<p><strong>数据在各层之间的传递过程</strong></p>
<p>在向下的过程中，需要添加下层协议所需要的首部或者尾部，而在向上的过程中不断拆开首部和尾部。</p>
<p>路由器只有下面三层协议，因为路由器位于网络核心中，不需要为进程或者应用程序提供服务，因此也就不需要传输层和应用层。</p>
</article><div class="tag_share"><div class="post_share"><div class="social-share" data-image="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%93%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E5%90%8E%EF%BC%8C%E5%88%B0%E7%BD%91%E9%A1%B5%E6%98%BE%E7%A4%BA%EF%BC%8C%E6%9C%9F%E9%97%B4%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88"><span class="toc-number">1.</span> <span class="toc-text">当键入网址后，到网页显示，期间发生了什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90%E5%8D%8F%E8%AE%AE%20ARP-Address-Resolution-Protocol"><span class="toc-number">2.</span> <span class="toc-text">地址解析协议 ARP(Address Resolution Protocol)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E9%99%85%E6%8E%A7%E5%88%B6%E6%8A%A5%E6%96%87%E5%8D%8F%E8%AE%AE%20ICMP-Internet-Control-Message-Protocol"><span class="toc-number">3.</span> <span class="toc-text">网际控制报文协议 ICMP(Internet Control Message Protocol)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%92%8C%E8%B7%AF%E7%94%B1%E5%99%A8%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.</span> <span class="toc-text">交换机和路由器的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%20DNS%20%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E4%B8%80%E5%BC%80%E5%A7%8B%E5%B0%B1%E6%98%AF%E4%BB%8E%E6%A0%B9%E5%9F%9F%E5%90%8D%E5%BC%80%E5%A7%8B%E6%9F%A5%E8%AF%A2%E5%90%97%EF%BC%9F"><span class="toc-number">5.</span> <span class="toc-text">查询 DNS 服务器的时候，一开始就是从根域名开始查询吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95"><span class="toc-number">6.</span> <span class="toc-text">拥塞控制算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E5%92%8C%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">7.</span> <span class="toc-text">流量控制和拥塞控制的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%20%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="toc-number">8.</span> <span class="toc-text">TCP 的三次握手</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%20%E7%9A%84%E5%9B%9B%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="toc-number">9.</span> <span class="toc-text">TCP 的四次握手</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%20%E7%9A%84%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6%E3%80%81%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E3%80%81%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E3%80%81%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="toc-number">10.</span> <span class="toc-text">TCP 的重传机制、滑动窗口、流量控制、拥塞控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTPS%20%E5%92%8C%20HTTP%20%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">11.</span> <span class="toc-text">HTTPS 和 HTTP 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E5%92%8C%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">12.</span> <span class="toc-text">对称加密和非对称加密的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#https%20%E7%9A%84%20ssl%20%E8%BF%9E%E6%8E%A5%E8%BF%87%E7%A8%8B"><span class="toc-number">13.</span> <span class="toc-text">https 的 ssl 连接过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%A6%82%E4%BD%95%E9%AA%8C%E8%AF%81%E8%AF%81%E4%B9%A6%E7%9A%84%E5%90%88%E6%B3%95%E6%80%A7"><span class="toc-number">14.</span> <span class="toc-text">客户端如何验证证书的合法性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%AE%A9%20UDP%20%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93"><span class="toc-number">15.</span> <span class="toc-text">如何让 UDP 可靠传输</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP%20%E7%9A%84%E7%8A%B6%E6%80%81%E7%A0%81%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">16.</span> <span class="toc-text">HTTP 的状态码有哪些</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%20%E5%92%8C%20UDP%20%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">17.</span> <span class="toc-text">TCP 和 UDP 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%20MAC%20%E5%9C%B0%E5%9D%80"><span class="toc-number">18.</span> <span class="toc-text">什么是 MAC 地址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MAC%20%E5%9C%B0%E5%9D%80%E5%86%B2%E7%AA%81%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="toc-number">19.</span> <span class="toc-text">MAC 地址冲突怎么办？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MAC%20%E5%9C%B0%E5%9D%80%E8%83%BD%E5%90%A6%E6%9B%B4%E6%94%B9"><span class="toc-number">20.</span> <span class="toc-text">MAC 地址能否更改</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E4%B8%AD%E4%B8%80%E4%B8%AA%E5%8C%85%E5%A4%B1%E6%95%88%E4%BA%86%EF%BC%9F"><span class="toc-number">21.</span> <span class="toc-text">怎么判断一个网络传输中一个包失效了？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E4%B8%80%E4%B8%AA%E5%8C%85%E6%8A%A5%E9%94%99%E6%97%A0%E7%94%A8%E4%BA%86%EF%BC%8C%E7%BD%91%E7%BB%9C%E4%B8%AD%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">22.</span> <span class="toc-text">如果一个包报错无用了，网络中会发生什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IPv4%20%E5%92%8C%20IPv6%20%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">23.</span> <span class="toc-text">IPv4 和 IPv6 的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Cookies"><span class="toc-number">24.</span> <span class="toc-text">Cookies</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Session"><span class="toc-number">25.</span> <span class="toc-text">Session</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Cookie%20%E5%92%8C%20Session%20%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">26.</span> <span class="toc-text">Cookie 和 Session 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A6%81%E7%94%A8%20Cookie%20%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%20Session-ID"><span class="toc-number">27.</span> <span class="toc-text">禁用 Cookie 如何使用 Session ID?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#http%20%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87%E4%B8%AD%EF%BC%8Chost%20%E5%AD%97%E6%AE%B5%E6%98%AF%E5%BF%85%E9%A1%BB%E5%AD%98%E5%9C%A8%E7%9A%84%E5%90%97%EF%BC%9F"><span class="toc-number">28.</span> <span class="toc-text">http 请求报文中，host 字段是必须存在的吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#http%20%E6%96%B9%E6%B3%95"><span class="toc-number">29.</span> <span class="toc-text">http 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GET%20%E5%92%8C%20POST%20%E8%AF%B7%E6%B1%82%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">30.</span> <span class="toc-text">GET 和 POST 请求的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E6%A0%A1%E9%AA%8C%E7%94%A8%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">31.</span> <span class="toc-text">网络各层校验用的是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%20%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E7%9A%84%E6%AD%A3%E7%A1%AE%E6%80%A7%EF%BC%9F"><span class="toc-number">32.</span> <span class="toc-text">TCP 如何保证数据的正确性？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-1-0-1-1-2-0%20%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">33.</span> <span class="toc-text">HTTP 1.0 &#x2F; 1.1 &#x2F; 2.0 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%20TCP%20%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%98%AF%E5%A4%9A%E5%B0%91%EF%BC%9F"><span class="toc-number">34.</span> <span class="toc-text">最大 TCP 连接数是多少？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%20SQL%20%E6%B3%A8%E5%85%A5%EF%BC%9F"><span class="toc-number">35.</span> <span class="toc-text">什么是 SQL 注入？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AF%8F%E4%B8%80%E5%B1%82%E5%AF%B9%E5%BA%94%E7%9A%84%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">36.</span> <span class="toc-text">每一层对应的网络协议有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%20TIME-WAIT-%20%E7%8A%B6%E6%80%81%E5%BF%85%E9%A1%BB%E7%AD%89%E5%BE%85%20-2MSL-%20%E7%9A%84%E6%97%B6%E9%97%B4%EF%BC%9F"><span class="toc-number">37.</span> <span class="toc-text">为什么 TIME-WAIT 状态必须等待 2MSL 的时间？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DNS%20%E7%9A%84%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B"><span class="toc-number">38.</span> <span class="toc-text">DNS 的解析过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%9F%E5%90%8D%E7%BC%93%E5%AD%98"><span class="toc-number">39.</span> <span class="toc-text">域名缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">40.</span> <span class="toc-text">计算机网络体系结构</span></a></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2022 By 陈泽豪</div><div class="footer_custom_text">我是豪豪</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex@latest/dist/contrib/copy-tex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/contrib/copy-tex.css"><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script><script>(() => {
  const $mermaidWrap = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaidWrap.length) {
    window.runMermaid = () => {
      window.loadMermaid = true
      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

      Array.from($mermaidWrap).forEach((item, index) => {
        const mermaidSrc = item.firstElementChild
        const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
        const mermaidID = 'mermaid-' + index
        const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent
        mermaid.mermaidAPI.render(mermaidID, mermaidDefinition, (svgCode) => {
          mermaidSrc.insertAdjacentHTML('afterend', svgCode)
        })
      })
    }

    const loadMermaid = () => {
      window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
    }

    window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
  }
})()</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script></div></body></html>